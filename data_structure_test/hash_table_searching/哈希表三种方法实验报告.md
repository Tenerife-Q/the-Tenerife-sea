# 哈希表三种方法实验报告

---

## 一、实验目的

1. 理解哈希表的基本原理及散列冲突的解决方法。
2. 熟悉线性探测法、二次探测法、链地址法三种常用冲突解决技术。
3. 掌握哈希表的查找、插入、删除等基本操作，并统计平均查找长度（ASL）。
4. 能够通过交互式代码实现、对比三种方法在不同冲突场景下的表现。

---

## 二、算法核心思想

### 1. 线性探测法（开放定址法）

- **基本思想**：当哈希冲突发生时，顺序地向后探查下一个表项，直到找到空位或表满为止。
- **典型流程代码片段**（摘自`interactive_hash_table.c`）：

```c
// 线性探测插入核心算法
int index = hashFunc(key) % hashTable->tableSize;
int originalIndex = index;
int probeCount = 1;

// 检查是否已存在
int tempIndex = index;
while (hashTable->table[tempIndex].status != 0) {
    if (hashTable->table[tempIndex].status == 1 && 
        hashTable->table[tempIndex].key == key) {
        // 重复元素，不插入
        return -1;
    }
    tempIndex = (tempIndex + 1) % hashTable->tableSize;
    if (tempIndex == originalIndex) break;
}

// 寻找插入位置
while (hashTable->table[index].status == 1) {
    index = (index + 1) % hashTable->tableSize;
    probeCount++;
    if (index == originalIndex) {
        // 无可用位置
        return -1;
    }
}
// 插入元素
hashTable->table[index].key = key;
hashTable->table[index].status = 1;
```

### 2. 二次探测法

- **基本思想**：冲突时按照`H(key) + i^2 (mod m)`的方式探测空位，减少“堆积”现象。
- **典型流程代码片段**（摘自`interactive_quadratic_probe.c`）：

```c
int index = divisionMethod(key) % hashTable->size;
int i = 0;
while (hashTable->table[(index + i * i) % hashTable->size].status == 1) {
    int currentPos = (index + i * i) % hashTable->size;
    if (hashTable->table[currentPos].key == key) {
        // 已存在
        return -1;
    }
    i++;
    if (i >= hashTable->size) {
        // 无可用位置
        return -1;
    }
}
int pos = (index + i * i) % hashTable->size;
hashTable->table[pos].key = key;
hashTable->table[pos].status = 1;
```

### 3. 链地址法

- **基本思想**：每个哈希槽存储一个链表，冲突元素插入该链表头部，理论上没有表满问题。
- **典型流程代码片段**（摘自`interactive_chain_division_clean.c`）：

```c
int index = hashFunc(key) % hashTable->tableSize;
ListNode *cur = hashTable->table[index];
while (cur) {
    if (cur->key == key) {
        // 已存在
        return;
    }
    cur = cur->next;
}
// 头插法加入链表
ListNode *newNode = (ListNode*)malloc(sizeof(ListNode));
newNode->key = key;
newNode->next = hashTable->table[index];
hashTable->table[index] = newNode;
```

---

## 三、逻辑结构与存储结构分析

### 1. 线性探测法

- **逻辑结构**  
  采用一维数组作为哈希表的逻辑结构。每个数组单元包含键值、状态（空/占用/删除）、探测次数等信息。

- **存储结构**  
  ```c
  typedef struct {
      int key;
      int status;     // 0:空闲, 1:已占用, 2:已删除
      int probeCount; // 探测次数
  } HashNode;

  typedef struct {
      HashNode *table;
      int tableSize;
      int count;
      int totalSearchLength;
  } OpenHashTable;
  ```
  通过数组物理连续存储，适合随机访问。

### 2. 二次探测法

- **逻辑结构**  
  同样是一维数组，每次冲突时按`i^2`步长跳跃，避免线性探测的“堆积”现象。

- **存储结构**  
  ```c
  typedef struct {
      int key;
      int status; // 0:空闲, 1:已占用, 2:已删除
  } HashNode;

  typedef struct {
      HashNode *table;
      int size;
      int count;
  } OpenHashTable;
  ```
  简化探测次数统计，但依赖于质数表长保证每次探测能覆盖全表。

### 3. 链地址法

- **逻辑结构**  
  基于**数组+链表**的结构。数组每一格为链表头指针，冲突元素以链表插入。

- **存储结构**  
  ```c
  typedef struct ListNode {
      int key;
      struct ListNode *next;
      int probeCount; // 在链表中的序号
  } ListNode;

  typedef struct {
      ListNode **table;
      int tableSize;
      int count;
      int totalSearchLength;
  } ChainHashTable;
  ```
  空间灵活，无表满限制，链表节点存储在堆中，适合冲突多的场景。

---

## 四、主要功能实现列表

> *本节略，依然保持原样（见代码注释及菜单部分），可根据实际实验填写。*

---

## 五、实验思考与总结

### 1. 三种方法的适用场景

- **线性探测法**：适合装载因子较小（<0.7），数据量与表长接近时性能下降明显，存在“堆积”现象，删除复杂。
- **二次探测法**：在表长为4k+3质数时，有效减轻堆积效应。适合对查找效率要求较高且可接受一定实现复杂度的场景。
- **链地址法**：最灵活，适合动态增长和高冲突情况。理论上无表满问题，删除操作简单，ASL受冲突分布影响最小。

### 2. 优缺点比较

| 方法       | 优点                                                         | 缺点                                          |
|------------|--------------------------------------------------------------|----------------------------------------------|
| 线性探测   | 实现简单，数组存储紧凑，缓存友好                             | 堆积严重，查找效率易下降，删除复杂                          |
| 二次探测   | 缓解线性堆积，提高查找效率                                   | 需选合适表长，代码实现略复杂，依然可能发生二次堆积            |
| 链地址法   | 灵活扩展，无表满限制，删除简单，理论ASL最好                  | 需动态分配链表节点，空间利用率略低，遍历链表时缓存利用差      |

### 3. 平均查找长度（ASL）与装载因子的关系

- 开放定址法ASL随装载因子快速上升，尤其在0.7以上。
- 链地址法ASL理论为`1+α/2`，实际略高但增长平缓。

### 4. 其他思考与体会

- 哈希函数选择与表长质数设计对性能影响极大。
- 实验中可观察到不同冲突模式（集中/分散/混合）对查找效率的显著影响。
- 线性与二次探测适合静态数据集，链地址法适合动态变化和高冲突数据。
- 现代高性能哈希表常结合多种技术（如Robin Hood、Hopscotch等），兼顾速度与空间效率。

---

## 六、附录：核心代码参考

> 见前文**算法核心思想**部分，源代码详见附件。

---