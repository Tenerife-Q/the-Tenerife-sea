#include <iostream>
#include <bitset> // 专门用来打印二进制的神器
using namespace std;

// 辅助函数：把 int 打印成 8 位的二进制，方便观察
void print_binary(int x, string msg) {
    cout << msg << ": " << x << " \t-> 二进制: " << bitset<8>(x) << endl;
}

int main() {
    cout << "=== 第一部分：基础算术替代 (极速版) ===" << endl;
    
    int n = 10;
    // 1. 判断奇偶 (替代 n % 2)
    // 原理：二进制最后一位是1就是奇数，0就是偶数
    if (n & 1) cout << "1. 奇数" << endl;
    else cout << "1. 偶数" << endl;

    // 2. 乘除法 (替代 *2 和 /2)
    // 原理：左移一位 = 乘2，右移一位 = 除2 (向下取整)
    print_binary(n, "原始值");
    print_binary(n << 1, "2. 左移一位 (n*2)"); 
    print_binary(n >> 1, "3. 右移一位 (n/2)"); 

    cout << "\n=== 第二部分：第 k 位的精准手术 (最常用！) ===" << endl;
    // 场景：用一个整数表示一个集合，第 k 位是 1 代表“选了第 k 个物品”
    // 注意：位置通常从 0 开始数 (最右边是第 0 位)
    
    int x = 0; // 初始：空集，全是 0
    int k = 2; // 我们想操作第 2 位 (也就是代表 4 的那一位)

    // 4. 把第 k 位变成 1 (Set Bit)
    // 公式：x | (1 << k)
    x = x | (1 << k); 
    print_binary(x, "4. 把第2位设为1");

    // 5. 检查第 k 位是不是 1 (Check Bit)
    // 公式：(x >> k) & 1
    if ((x >> k) & 1) cout << "5. 检查发现第2位 确实是 1" << endl;
    
    // 6. 把第 k 位变成 0 (Clear Bit)
    // 公式：x & ~(1 << k)  (先把 1 左移，再取反，再与)
    x = x & ~(1 << k);
    print_binary(x, "6. 把第2位变回0");

    // 7. 把第 k 位取反 (Flip Bit: 0变1, 1变0)
    // 公式：x ^ (1 << k)
    x = x ^ (1 << k);
    print_binary(x, "7. 第2位取反(变1)");
    x = x ^ (1 << k);
    print_binary(x, "7. 再次取反(变0)");

    cout << "\n=== 第三部分：XOR (异或) 的魔法 ===" << endl;
    // 口诀：相同为0，不同为1。也可以理解为“不进位加法”。
    
    // 8. 交换两个数 (不需要临时变量) - 了解即可，现代编译器优化很好，直接 swap 更快
    int a = 5, b = 9;
    a ^= b; b ^= a; a ^= b;
    cout << "8. 交换后: a=" << a << ", b=" << b << endl;

    // 9. 自销毁特性 (重要！)
    // x ^ x = 0
    // x ^ 0 = x
    // 应用：在一堆两两配对的数字中，找那个唯一的单身狗
    int arr[] = {3, 5, 3, 9, 5}; // 9 是单身
    int ans = 0;
    for(int num : arr) ans ^= num;
    cout << "9. 数组里落单的数字是: " << ans << endl;

    cout << "\n=== 第四部分：关于 2 的特技 ===" << endl;
    
    // 10. 判断是不是 2 的幂 (如 2, 4, 8, 16...)
    // 原理：2的幂，二进制里只有一个 1。减 1 后，那一位变成 0，后面全变成 1。
    // 公式：x & (x - 1)
    int p = 16;
    if ((p & (p - 1)) == 0) cout << "10. " << p << " 是2的幂" << endl;

    // 11. 消除二进制里最右边的 1 (甚至比 lowbit 还常用)
    // 公式：x = x & (x - 1)
    int m = 12; // 1100
    print_binary(m, "11. 原始 m");
    m = m & (m - 1);
    print_binary(m, "11. 消除最右 1 后"); // 变成 1000

    return 0;
}