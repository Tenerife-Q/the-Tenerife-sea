#include <iostream>
using namespace std;

/*
 * 📚 核心理论重修：差分与前缀和的"血缘关系"
 * ==========================================
 * 
 * 1. 根本定义 (The Definition)
 *    - 矩阵 A (原矩阵/前缀和矩阵): 我们最终想要看到的画面。
 *    - 矩阵 B (差分矩阵/指令矩阵): 我们操作的控制台。
 *    - 关系公式: A[i][j] = Σ (B[x][y])  (其中 1<=x<=i, 1<=y<=j)
 *    - 通俗理解: 
 *      A[i][j] 的值 = B 矩阵中 (i,j) 左上角区域所有元素的总和。
 * 
 * 2. "墨水效果"的物理原理 (The Ink Physics)
 *    问：为什么改动 B 的一个点，A 会变一大片？
 *    答：这是由"前缀和定义"决定的。
 *    
 *    如果我们修改了 B[x][y] += c：
 *    - 对于任何在 (x,y) 右下方的点 A[i][j] (即 i>=x 且 j>=y)：
 *      它们的"左上角求和区域"里，都包含了 B[x][y] 这个点。
 *    - 所以，它们在计算累加和时，都会把这个新增的 c 算进去。
 *    - 结果：从 (x,y) 到 (N,M) 的整个矩形区域，A 的值都会自动 +c。
 * 
 * 3. 巧妙的初始化 (The Initialization)
 *    问：怎么根据初始矩阵 A 构造出 B？
 *    
 *    方法一 (公式推导法): 
 *    B[i][j] = A[i][j] - A[i-1][j] - A[i][j-1] + A[i-1][j-1]
 *    (容易写错)
 *    
 *    方法二 (大神通用法 - 代码中使用):
 *    - 想象最开始 A 和 B 都是全 0 的空白画布。
 *    - "初始化" 其实就是 user 发出的一堆指令。
 *    - 比如：A[1][1] 本来是 5。我们就执行一次 "修改子矩阵 (1,1)~(1,1) +5"。
 *    - 比如：A[i][j] 本来是 v。我们就执行一次 "修改子矩阵 (i,j)~(i,j) +v"。
 *    - 这样，初始化的逻辑就和修改的逻辑完全统一了！只需要写一个 insert 函数。
 * 
 * 4. 最终复原 (The Restoration)
 *    问：操作完 B 之后，怎么算回 A？
 *    答：求二维前缀和。
 *    
 *    数学公式: 
 *    A[i][j] = A[i-1][j] + A[i][j-1] - A[i-1][j-1] + B[i][j]
 *    
 *    代码实现 (原地更新，省空间):
 *    b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1];
 *    (这一步之后，b[i][j] 里面存的就不再是差分值，而是变成前缀和了)
 */

const int N = 1010;
int n, m, q;
int a[N][N], b[N][N];

// 核心插入函数
void insert(int x1, int y1, int x2, int y2, int c) {
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    cout << "请输入矩阵行数 n，列数 m，操作次数 q: ";
    if (!(cin >> n >> m >> q)) return 0;

    cout << "请输入初始矩阵:" << endl;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
            // 构造差分矩阵
            // 初始化也可以看作是在 (i,j) 到 (i,j) 的小矩形上加上 grid[i][j]
            insert(i, j, i, j, a[i][j]);
        }
    }

    cout << "请输入 " << q << " 组操作 (x1 y1 x2 y2 c):" << endl;
    while (q--) {
        int x1, y1, x2, y2, c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1, y1, x2, y2, c);
    }

    // 还原矩阵 A (求二维前缀和)
    cout << "修改后的矩阵:" << endl;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            // b[i][j] 自环更新为前缀和 (这还是二维前缀和的公式)
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];
            cout << b[i][j] << " ";
        }
        cout << endl;
    }

/*
 * 🎮 终极图解：数值轨迹追踪 (Full Matrix Trace)
 * ==========================================
 * 场景：4x5 矩阵 (为方便看清边界)，初始化全 0。
 * 目标：给中间子矩阵 (2,2) ~ (3,3) 加上 1。
 *      (即行2-3, 列2-3 的区域变 1，其余保持 0)
 * 
 * 初始 A 矩阵 (Diff Matrix B 计算前缀和得到):
 * 0 0 0 0 0
 * 0 0 0 0 0
 * 0 0 0 0 0
 * 0 0 0 0 0
 * 
 * ------------------------------------------
 * 
 * 步骤 1: b[x1][y1] += c  =>  b[2][2] += 1
 * 【含义】倒红墨水。从 (2,2) 开始，所有右下角区域 +1。
 * 
 * 此时还原出的 A 矩阵 (前缀和)：
 * 0 0 0 0 0
 * 0 1 1 1 1  <-- 从 (2,2) 开始全变 1
 * 0 1 1 1 1
 * 0 1 1 1 1
 * (问题：右边第4,5列多了，下边第4行也多了)
 * 
 * ------------------------------------------
 * 
 * 步骤 2: b[x1][y2+1] -= c  =>  b[2][4] -= 1
 * 【含义】剔除右侧多余部分。从 (2,4) 开始右下角 -1 (倒褪色剂)。
 * 
 * 此时还原出的 A 矩阵：
 * 0 0 0 0 0
 * 0 1 1 0 0  <-- Right! (1-1=0，右边干净了)
 * 0 1 1 0 0
 * 0 1 1 0 0  <-- 下方第4行还是多余 1
 * 
 * ------------------------------------------
 * 
 * 步骤 3: b[x2+1][y1] -= c  =>  b[4][2] -= 1
 * 【含义】剔除下方多余部分。从 (4,2) 开始右下角 -1。
 * 
 * 此时还原出的 A 矩阵：
 * 0 0 0 0 0
 * 0 1 1 0 0
 * 0 1 1 0 0
 * 0 0 0 -1 -1 <-- ❌ BUG出现 / 交叉区域污染！
 *                 Col 2,3: 1-1=0 (正确抵消)
 *                 Col 4,5: 0-1=-1 (错误！本来是0，减一次变成-1了)
 * 
 * 【原因分析】
 * 右下角交叉区域 (4,4)~(4,5) 既被步骤2减了一次，也被步骤3减了一次。
 * 
 * ------------------------------------------
 * 
 * 步骤 4: b[x2+1][y2+1] += c  =>  b[4][4] += 1
 * 【含义】补救右下角。从 (4,4) 开始右下角 +1。
 * 
 * 此时还原出的 A 矩阵：
 * 0 0 0 0 0
 * 0 1 1 0 0
 * 0 1 1 0 0
 * 0 0 0 0 0  <-- ✅ 完美修复！(-1+1=0)
 * 
 * ==========================================
 * 🔄 回归抽象：公式记忆法
 * 
 * 只要记住 "右下角被多减了一次"，公式就能在脑中构建：
 * 
 * 1. 左上角 (x1, y1):       + c  (开始覆盖整个右下)
 * 2. 右边界外 (x1, y2+1):   - c  (砍掉右半边多余的)
 * 3. 下边界外 (x2+1, y1):   - c  (砍掉下半边多余的)
 * 4. 右下交叉 (x2+1, y2+1): + c  (交叉部分被砍了两刀，补回一刀)
 */

    return 0;
}
