#include <iostream>
using namespace std;

/*
 * ❓ 疑点解答：坐标是不是反了？
 * ==========================================
 * 这确实是很多人的困惑点，主要源于 "数学坐标系" vs "矩阵坐标系" 的习惯差异。
 * 
 * 1. 数学/物理坐标系 (Cartesian):
 *    - x轴: 水平方向 (左右)
 *    - y轴: 垂直方向 (上下)
 *    - 点 (x,y) 对应 (列, 行)
 * 
 * 2. 数组/矩阵编程习惯 (Matrix):
 *    - a[i][j]: 第一维 i 通常表示 "第几行" (Row)，第二维 j 表示 "第几列" (Col)
 *    - 题目描述中通常说 "第 x 行 第 y 列" => x 是行，y 是列。
 * 
 * 👉 在 AcWing 和大多数算法题中：
 *    x 通常代表 行 (Row)，即垂直高度。
 *    y 通常代表 列 (Col)，即水平宽度。
 *    所以代码中 for (i = x1; i <= x2) 是在遍历行。
 *    (如果不习惯，可以把变量名改为 r1, c1, r2, c2 即 row/col)
 * 
 * ------------------------------------------
 * 
 * 💡 本质复盘：如何想到用差分？
 * 
 * 场景：给你一块白布，要在上面的 (x1, y1) 到 (x2, y2) 涂黑。
 * 
 * 方法一：纯暴力 (Naive)
 *   for (r = x1 到 x2)
 *     for (c = y1 到 y2)
 *        a[r][c]++;
 *   复杂度：每一次涂色都是 面积大小。如果涂 1000 次大面积，直接 TLE。
 * 
 * 方法二：逐行偷懒 (Row-Optimized) -> 即本代码方法
 *   我们发现：每一行要涂黑的都是 "连续的一段" (从 y1 到 y2)。
 *   对于 "连续区间修改"，我们可以用 **一维差分** 优化！
 *   
 *   于是遍历每一行 r (从 x1 到 x2):
 *     不用一个一个涂格子了，只需在头(y1)打个勾，尾巴后(y2+1)打个叉。
 *     a[r][y1]++; 
 *     a[r][y2+1]--;
 * 
 *   复杂度：每一次涂色只花费 高度大小 (Height)。比完全暴力快多了。
 * 
 * 方法三：极致偷懒 (Full 2D Difference) -> 13_difference_2d.cpp
 *   连行都不想遍历了？
 *   那就把二维矩阵看作整体，只修 4 个角。
 *   复杂度：O(1)。
 */

const int N = 1010;
int n, m;
int a[N][N]; // 差分数组

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    // 输入 n (网格大小) 和 m (地毯数量)
    cout << "请输入网格大小 n 和地毯数量 m: ";
    // 注意：部分题目可能先输 m 再输 n，请仔细看题
    if (!(cin >> n >> m)) return 0;

    cout << "请输入 " << m << " 个地毯的坐标 (x1 y1 x2 y2):" << endl;
    while (m--) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;

        /* 
         * 🖼️ 逐行操作 (Row-by-Row)
         * 假设 x 代表行 (Row), y 代表列 (Col)
         * 遍历每一个涉及到的行 i
         */
        for (int i = x1; i <= x2; i++) {
            // 在当前行 i，我们需要把 [y1, y2] 区间全部 +1
            // 利用一维差分原理：
            a[i][y1]++;      // 起点 +1
            a[i][y2 + 1]--;  // 终点后一位 -1
        }
    }

    // 还原原数组 (求前缀和)
    // 注意：因为我们是按行独立做差分，所以还原时也是按行独立求一维前缀和
    cout << "每个格子被覆盖的次数:" << endl;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            // 经典的 一维前缀和 公式
            // a[i][j] = a[i][j-1] + b[i][j] (这里直接在原数组累加)
            a[i][j] += a[i][j - 1]; 
            
            cout << a[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}

/*
 * 🧵 逐行还原全过程图解 (Trace Analysis)
 * ==========================================
 * 这是一种 "降维打击" 的思路：
 * 把麻烦的 2D 区域覆盖，拆解成 H 次简单的 1D 数组操作。
 * 
 * 假设：3x3 网格。
 * 操作：地毯铺在 (1,1) 到 (2,2)。
 *      x1=1, y1=1
 *      x2=2, y2=2
 * 
 * ------------------------------------------
 * 
 * 第一阶段：覆盖 (Differential Construction)
 * 逻辑：for (i = x1 到 x2) { b[i][y1]++; b[i][y2+1]--; }
 * 
 * 1. 处理第 1 行 (i=1):
 *    - b[1][1]++;   -> b[1]变成 [1, 0, 0]
 *    - b[1][3]--;   -> b[1]变成 [1, 0, -1]  (注意 y2+1=3)
 * 
 * 2. 处理第 2 行 (i=2):
 *    - b[2][1]++;   -> b[2]变成 [1, 0, 0]
 *    - b[2][3]--;   -> b[2]变成 [1, 0, -1]
 * 
 * 3. 处理第 3 行 (i=3):
 *    - 没在范围内，不动。
 * 
 * 此时的差分矩阵 B:
 * [1, 0, -1]
 * [1, 0, -1]
 * [0, 0,  0]
 * 
 * ------------------------------------------
 * 
 * 第二阶段：还原 (Prefix Sum Construction)
 * 逻辑：每一行独立计算前缀和 (a[i][j] += a[i][j-1])
 * 
 * 1. 还原第 1 行:
 *    - j=1: 1
 *    - j=2: 0 + 1 = 1
 *    - j=3: -1 + 1 = 0
 *    -> Row 1: [1, 1, 0] (前两格被覆盖，正确)
 * 
 * 2. 还原第 2 行:
 *    - j=1: 1
 *    - j=2: 0 + 1 = 1
 *    - j=3: -1 + 1 = 0
 *    -> Row 2: [1, 1, 0] (前两格被覆盖，正确)
 * 
 * 3. 还原第 3 行:
 *    -> Row 3: [0, 0, 0] (这一行没被地毯碰到)
 * 
 * ------------------------------------------
 * 
 * 总结：
 * 该方法的本质是把 "面" 切成了 "条"。
 * - 优点：思维极其简单，就是反复做一维差分。
 * - 缺点：如果地毯非常多且非常高 (x1=1, x2=1000)，修改的时间复杂度是 O(m * n)，
 *        而标准二维差分是 O(m)。但本题数据范围允许这样做。
 */
