#include <iostream>
#include <algorithm>

using namespace std;

/*
 * 区间合并 - 董晓算法（计算区间总长度版本）
 * 
 * ============ 董晓老师讲解 ============
 * 
 * 对比 AcWing 803（求个数）和 洛谷 P1496（求长度）
 * 核心思想一致，只是统计方式不同
 * 
 * ============ 三种情况图解 ============
 * 
 * 1. 覆盖：跳过
 *    st          ed
 *    ├───────────┤
 *       ├──┤ r       <- 新区间被包含，跳过
 *          l
 * 
 * 2. 重叠：更新右端点
 *    st      ed
 *    ├───────┤
 *          ├────┤    <- 有交集，扩展右端点
 *          l    r
 *    操作: st=ed; ed=a[i].r; sum+=ed-st;
 * 
 * 3. 相离：新开区间
 *    st  ed
 *    ├───┤
 *                ├──┤  <- 无交集，结算并开新区间
 *                l  r
 *    操作: st=a[i].l; ed=a[i].r; sum+=ed-st;
 * 
 * ============ 洛谷 P1496 - 火烧赤壁 ============
 * 
 * 曹操的船在环线上，给定n个起火部分的区间 [a, b]
 * 区间可能重叠，求燃烧位置的总长度
 * 
 * 输入: n 个区间 [a, b]（左闭右开）
 * 输出: 合并后的总长度
 * 
 * 例子:
 *   输入: 3
 *         -1 1
 *         5 11
 *         2 9
 *   
 *   排序: [-1,1], [2,9], [5,11]
 *   合并: [-1,1]长度2, [2,11]长度9
 *   输出: 11
 */

struct Line {
    int l, r;  // 区间左右端点
    
    // 排序规则：按左端点排序
    bool operator < (const Line &t) const {
        return l < t.l;
    }
} a[200005];

int n;
int st, ed;    // 当前维护的区间 [st, ed]
int sum;       // 总长度累加器

int main() {
    cout << "=== 区间合并 - 董晓算法（求长度版）===" << endl;
    cout << "解决: 洛谷 P1496 火烧赤壁\n" << endl;
    
    while (true) {
        cout << "选择模式:" << endl;
        cout << "  1. 题目模式（输入区间，输出总长度）" << endl;
        cout << "  2. 预设示例" << endl;
        cout << "  3. 退出" << endl;
        cout << "请选择: ";
        
        int choice;
        if (!(cin >> choice) || choice == 3) break;
        
        if (choice == 1) {
            // 题目模式
            cout << "\n请输入区间个数 N: ";
            cin >> n;
            
            cout << "请输入 " << n << " 个区间 (格式: l r):" << endl;
            for (int i = 1; i <= n; i++) {
                cin >> a[i].l >> a[i].r;
            }
            
        } else if (choice == 2) {
            // 预设示例
            cout << "\n=== 预设示例 ===" << endl;
            cout << "区间: [-1,1], [5,11], [2,9]\n" << endl;
            
            n = 3;
            a[1] = {-1, 1};
            a[2] = {5, 11};
            a[3] = {2, 9};
            // 这里存的是左闭右开区间
            // a[1] = {-1, 1} 表示 [-1, 1)
            // a[i].l 可以表示区间的起点，a[i].r 表示区间的终点（不包含）
        }
        
        // 按左端点排序
        sort(a + 1, a + n + 1);
        
        cout << "排序后:" << endl;
        for (int i = 1; i <= n; i++) {
            cout << "  [" << a[i].l << ", " << a[i].r << "]" << endl;
        }
        
        // 初始化第一个区间
        st = a[1].l;
        ed = a[1].r;
        sum = ed - st;  // 第一个区间的长度
        
        cout << "\n合并过程:" << endl;
        cout << "初始: [" << st << ", " << ed << "], 长度 = " << sum << endl;
        
        // 从第2个区间开始扫描
        for (int i = 2; i <= n; i++) {
            cout << "\n处理区间[" << a[i].l << ", " << a[i].r << "]: ";
            
            if (a[i].l <= ed) {
                // 情况1+2: 覆盖或重叠
                if (a[i].r <= ed) {
                    // 情况1: 完全被包含，跳过
                    cout << "被包含，跳过" << endl;
                    // ed 不变
                } else {
                    // 情况2: 有交集，扩展右端点
                    cout << "重叠，扩展 [" << st << ", " << ed << "] -> [" << st << ", " << a[i].r << "]" << endl;
                    int old_ed = ed;
                    st = ed;        // 从旧的 ed 开始
                    ed = a[i].r;    // 扩展到新的 r
                    sum += ed - st; // 累加扩展的长度
                    cout << "  增加长度: " << (ed - st) << ", 累计 = " << sum << endl;
                }
            } else {
                // 情况3: 相离，开始新区间
                cout << "相离，结算并开新区间 [" << a[i].l << ", " << a[i].r << "]" << endl;
                st = a[i].l;
                ed = a[i].r;
                sum += ed - st;  // 累加新区间长度
                cout << "  增加长度: " << (ed - st) << ", 累计 = " << sum << endl;
            }
        }
        
        cout << "\n最终答案: " << sum << "\n" << endl;
    }
    
    return 0;
}

/*
 * ============ 测试用例 ============
 * 
 * 【案例1 - 洛谷 P1496 样例】
 * 
 * 输入:
 *   3
 *   -1 1
 *   5 11
 *   2 9
 * 
 * 过程:
 *   排序: [-1,1], [2,9], [5,11]
 *   
 *   初始: [-1, 1], 长度 = 2
 *   
 *   处理 [2, 9]:
 *     2 > 1 (相离)
 *     开新区间，sum += 9-2 = 7
 *     累计 = 2 + 7 = 9
 *   
 *   处理 [5, 11]:
 *     5 <= 9 (重叠)
 *     扩展 [2,9] -> [2,11]
 *     sum += 11-9 = 2
 *     累计 = 9 + 2 = 11
 * 
 * 输出: 11
 * 
 * 【案例2 - 全部重叠】
 * 
 * 输入:
 *   3
 *   1 10
 *   2 5
 *   3 7
 * 
 * 输出: 9
 * 
 * 【案例3 - 完全分离】
 * 
 * 输入:
 *   3
 *   1 3
 *   5 7
 *   10 15
 * 
 * 输出: 2 + 2 + 5 = 9
 * 
 * ============ 董晓算法 vs 标准算法 ============
 * 
 * 标准算法（AcWing 803）:
 *   - 用 vector 存储合并后的所有区间
 *   - 最后遍历计算总个数或总长度
 *   - 代码简洁，通用性强
 * 
 * 董晓算法（洛谷 P1496）:
 *   - 边合并边累加长度，空间 O(1)
 *   - 适合只需要统计长度/个数的场景
 *   - 不需要存储合并后的区间
 * 
 * 区别在于:
 *   - 标准: 完整记录合并过程
 *   - 董晓: 只记录统计结果（更省空间）
 * 
 * ============ 关键点 ============
 * 
 * 1. 必须先排序（按左端点）
 * 2. 初始化第一个区间
 * 3. 三种情况的判断条件:
 *    - a[i].l > ed  -> 相离
 *    - a[i].r <= ed -> 覆盖
 *    - 其他         -> 重叠
 * 4. 累加时机:
 *    - 重叠: sum += a[i].r - ed
 *    - 相离: sum += a[i].r - a[i].l
 */
