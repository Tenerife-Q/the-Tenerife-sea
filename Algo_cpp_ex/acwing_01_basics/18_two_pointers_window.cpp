#include <iostream>

using namespace std;

/*
 * 洛谷 P1638 - 逛画展 (最小覆盖子串模型)
 * 
 * 题目描述：
 * 有 N 幅画，对应 M 个画家。我们要买连续的一段票 [a, b]，
 * 使得这段区间内包含所有 M 个画家的至少一幅画。
 * 求最短的 [a, b]。如果长度一样，输出 a 最小的那个。
 * 
 * 核心逻辑：尺取法 (Sliding Window)
 * 
 * 模型：像呼吸一样伸缩。
 * 1. 吸气 (Expand): j 往右跑。
 *    把新的画纳入窗口，更新计数器 cnt[a[j]]。
 *    如果这是该画家的第一幅画，num++。
 * 
 * 2. 呼气 (Shrink): i 往右跑。
 *    当 num == m (集齐所有画家) 时，说明当前窗口合法。
 *    此时，我们要尝试“优化”窗口，即把左边多余的画扔掉。
 *    扔掉 a[i] 后，如果 cnt[a[i]] 归零了，说明这位画家的画没了，num--，必须停止收缩。
 * 
 * 3. 记录：
 *    在每次 num == m 且收缩到极限时，更新最小长度结果。
 */

const int N = 1000005; // 画的数量 N <= 10^6
const int M = 2005;    // 画家的数量 M <= 2000

int a[N];       // 存储每幅画的画家编号
int cnt[M];     // 计数器：当前窗口内，画家 k 的画有几幅

int main() {
    // 既然是大量输入输出，不仅关同步，最好用 scanf/printf
    // 虽然这里还是演示 cin/cout 配合优化
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n, m;
    cout << "=== 最小覆盖子串 (画展问题) ===" << endl;
    cout << "该程序寻找包含所有 M 位画家的最短连续画作区间。" << endl;
    cout << "请输入画作总数 N 和画家总数 M (例如: 12 5): ";
    if (!(cin >> n >> m)) return 0;

    cout << "请输入 " << n << " 个整数 (代表每幅画的画家 ID): ";
    for (int k = 1; k <= n; k++) {
        cin >> a[k];
    }

    int num = 0;           // 当前窗口集齐了多少位不同的画家
    // 计数器 cnt[x] 记录当前窗口内画家 x 的画作数量
    // 我们需要用一个 map 或者数组 (如果 ID 小的话)
    // 题目中 ID 范围通常对应 M, 这里我们用全局数组 cnt[M]

    int min_len = 1e9;     // 记录遇到的最短区间长度
    int ans_l = 1, ans_r = n; // 最终答案

    int i = 1; // 左指针
    int j = 1; // 右指针
    
    cout << "\n----- 开始扫描窗口 -----" << endl;

    // j 是右指针，负责 "进货"
    while (j <= n) {
        // Step 1: 进货 (Add a[j])
        if (cnt[a[j]] == 0) {
            num++; // 如果之前没见过这位画家，那已集齐数量+1
        }
        cnt[a[j]]++;

        // Step 2: 退货 (Remove a[i])
        // 只要当前窗口合法 (num == m)，就尝试收缩左边界，看看能不能更短
        while (num == m) {
            // 在这一刻，区间 [i, j] 是合法的。
            // 记录答案
            if (j - i + 1 < min_len) {
                min_len = j - i + 1;
                ans_l = i;
                ans_r = j;
                cout << "发现合法区间: [" << i << ", " << j << "] 长度: " << min_len << endl;
            }

            // 尝试把左边的画扔掉
            cnt[a[i]]--;
            
            // 关键判断：扔掉后，如果这位画家的画没了，那就破坏了 "合法性"
            if (cnt[a[i]] == 0) {
                num--; // 破坏了 num==m 的条件，下一轮 while 就进不来了，j 必须继续往右找
            }
            
            i++; // 左指针右移 (即使 num 变小了，这一步也是要执行的，因为当前的 a[i] 已经被移除了)
        }
        j++;
    }

    cout << "------------------------------------------" << endl;
    if (min_len == 1e9) {
        cout << "无法找到包含所有画家的连续区间。" << endl;
    } else {
        cout << "最短区间长度: " << min_len << endl;
        cout << "区间范围: " << ans_l << " " << ans_r << endl;
    }

    return 0;
}

// 输入输出示例：
// === 最小覆盖子串 (画展问题) ===
// 该程序寻找包含所有 M 位画家的最短连续画作区间。
// 请输入画作总数 N 和画家总数 M (例如: 12 5): 12 5
// 请输入 12 个整数 (代表每幅画的画家 ID): 1 2 3 4 5 1 2 3 4 5 1 2
// ----- 开始扫描窗口 -----
// 发现合法区间: [1, 5] 长度: 5
// 发现合法区间: [2, 6] 长度: 5
// 发现合法区间: [3, 7] 长度: 5
// 发现合法区间: [4, 8] 长度: 5
// 发现合法区间: [5, 9] 长度: 5
// 发现合法区间: [6, 10] 长度: 5
// 发现合法区间: [7, 11] 长度: 5
// 发现合法区间: [8, 12] 长度: 5
// ------------------------------------------
// 最短区间长度: 5
// 区间范围: 1 5