#include <iostream>
#include <algorithm> // for max, abs

using namespace std;

/*
 * 差分经典应用 - IncDec Sequence (AcWing 100 / Luogu P4552)
 * 
 * 题目描述：
 * 给定一个长度为 n 的数列 a。
 * 每次可以选择一个区间 [l, r]，使下标在这个区间内的数都加 1 或者都减 1。
 * 求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少操作次数的情况下，最终得到的数列可能有多少种。
 * 
 * 解题思路 (基于董晓算法讲解):
 * 1. 目标：让 b[2] ~ b[n] 全变为 0。
 * 2. 统计 b[2] ~ b[n] 中正数总和 P，负数绝对值总和 Q。
 * 3. 最小操作次数 = max(P, Q)
 *    - 先用 min(P, Q) 次操作将一正一负抵消。
 *    - 剩下 |P - Q| 个同号元素，与 b[1] 或 b[n+1] 配对消耗掉。
 * 4. 最终结果种类 = |P - Q| + 1
 *    - 剩下的 |P - Q| 个操作，每次可以选择修改 b[1] (影响最终值) 或者修改 b[n+1] (不影响最终值)。
 */

const int N = 100010;
int n;
int a[N];
long long b[N]; // 差分数组，操作过程中值可能很大，开 long long 保险

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    cout << "请输入数列长度 n: ";
    if (!(cin >> n)) return 0;

    cout << "请输入 " << n << " 个整数: ";
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        // 构造差分
        b[i] = a[i] - a[i - 1];
    }

    /* 
     * 注意：我们只关心 b[2] 到 b[n]
     * b[1] 是基准值，不需要变成 0
     */
    long long p = 0; // 正数和
    long long q = 0; // 负数绝对值和

    for (int i = 2; i <= n; i++) {
        if (b[i] > 0) {
            p += b[i];
        } else {
            q -= b[i]; // 累加负数的绝对值
        }
    }

    // 输出结果
    // 1. 最少操作次数
    cout << "最少操作次数: " << max(p, q) << endl;
    
    // 2. 最终结果的种类数 (即 b[1] 可能的变种数量)
    // 注意：结果种类数只与剩下的未匹配项 abs(p - q) 有关
    cout << "最终结果种类: " << abs(p - q) + 1 << endl;

    return 0;
}

/*
 * 🎮 通俗图解：移山填海游戏
 * ==========================================
 * 目标：让 B[2]...B[n] 全部变为 0。
 * 
 * 例子 Trace:
 * 初始 A: [1, 2, 2, 1]
 * 初始 B: [1, +1, 0, -1]  (注: B[n+1]默认为0)
 * 
 * 现在的“地形”:
 * Index:  1    2    3    4    5
 * Value:  1   +1    0   -1    0
 *             (山)      (坑)
 * 
 * 统计:
 * P (正数总和) = 1  (来自 B[2])
 * Q (负数总和) = 1  (来自 B[4])
 * 
 * 步骤 1: 移山填海 (Type 1 操作)
 * 操作: 选 l=2, r=3。对应 B[2]--, B[4]++。
 * 含义: 把 B[2] 的山挖掉，填到 B[4] 的坑里。
 * 结果 B: [1, 0, 0, 0]
 * 次数: 1 次。
 * 
 * 状态: 山平了，坑也平了。P=0, Q=0。
 * 
 * 结论:
 * 最少操作 = max(1, 1) = 1
 * 结果种类 = abs(1 - 1) + 1 = 1 (只有一种结果: 全是1)
 * 
 * ------------------------------------------
 * 
 * 复杂例子 Trace:
 * 假设 B[2...n] 统计后: P=5 (多了5份土), Q=4 (缺4份土)
 * 
 * 1. 完美匹配 (min(P,Q) = 4次)
 *    我们执行 4 次“从山挖土填坑”。
 *    花费: 4 次。
 *    剩余: P=1 (还剩1份土), Q=0 (坑填满了)。
 * 
 * 2. 处理残局 (|P-Q| = 1次)
 *    手里还剩 1 份土，没坑可填了。
 *    选择 A: 堆到 B[1] (修改了最终的高度)
 *    选择 B: 扔到 B[n+1] (扔掉，不影响最终高度)
 *    花费: 1 次。
 * 
 * 总操作: 4 + 1 = 5 (也就是 max(5, 4))
 * 结果种类: 那 1 份土，可以选择“给B[1]”或“不给B[1]”，共 2 种可能。
 */

/*
 * 💡 深度解析：核心疑问 QA
 * ==========================================
 * Q1: 为什么要不断变换区间 [l, r]？
 * A1: 逆向思维。
 *     不是先有区间再看影响，而是为了消除特定的 b[i](正) 和 b[j](负)，
 *     我们 "精心设计" 了区间 [i, j-1] 来进行 "定点爆破"。
 * 
 * Q2: b[n+1] 到底是什么？
 * A2: "系统边界外的垃圾桶"。
 *     差分操作遵循能量守恒 (一正一负)。如果我们只想消除 b[i]，但找不到
 *     另一个负数来配对，我们就把副作用丢给 b[n+1]。
 *     题目只要求 [1~n] 相等，b[n+1] 变成多少完全不影响结果。
 * 
 * Q3: 为什么结果种类是 |P-Q| + 1？
 * A3: 这是一个 "天平分配" 问题 (线性自由度)。
 *     正负抵消后，剩下 K = |P-Q| 次操作机会。
 *     每次机会都有两个选择：
 *     1. 作用在 b[1] -> 改变最终所有数的高度。
 *     2. 作用在 b[n+1] -> 扔垃圾桶，最终高度不变。
 *     
 *     我们可以分配 0 次给 b[1], 1 次给 b[1], ... 直到 K 次全给 b[1]。
 *     从 0 到 K，一共有 K + 1 种选择。
 */
