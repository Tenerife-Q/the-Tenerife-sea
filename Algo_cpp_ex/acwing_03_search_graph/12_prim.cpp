/*
 * ============================================
 *   Prim 算法 (普里姆算法) - 最小生成树 (MST)
 *   时间复杂度：O(N^2) (适合稠密图)
 *   
 *   【什么是最小生成树？】
 *   给定 N 个点和 M 条边，每条边有一个权重(成本)。
 *   目标：挑出 N-1 条边，把所有点连通，且这 N-1 条边的总权重最小。
 *   例子：修路把所有城市连起来，怎么修总造价最低。
 *   
 *   【算法核心思想：贪心 (加点法)】
 *   集合 S: 已连通的点 (已修好路的车队)
 *   集合 V: 未连通的点 (还没修路的村庄)
 *   dist[i]: 点 i 到 "集合 S" 的最短距离 (注意：不是到起点的距离，是到集体的最近距离)
 *   
 *   【举例模拟 (对应代码流程)】
 *   假设有 3 个点:
 *   1-2 (距离10), 1-3 (距离20), 2-3 (距离5)
 *   初始：dist=[INF, INF, INF], st=[F, F, F], res=0
 *   
 *   --- 第一次循环 (i=0) ---
 *   1. 找点 (Step a): 
 *      扫描全图，dist全是INF。随便选一个作为起点，通常选 t=1。
 *   2. 特判起点 (Step b): 
 *      代码 `if (i) ...` 判断为假 (i=0)。
 *      解释：第一个点是"种子"，它进集合不需要花路费，所以 res 不加 dist[1]。
 *      标记 st[1] = true (1号点进集合)。
 *   3. 更新 (Step c):
 *      用 1号点 更新邻居：
 *      - dist[2] = min(INF, g[1][2]=10) -> 10
 *      - dist[3] = min(INF, g[1][3]=20) -> 20
 *   
 *   --- 第二次循环 (i=1) ---
 *   1. 找点 (Step a):
 *      扫描未连通的点 {2, 3}。
 *      dist[2]=10, dist[3]=20。选最小的 t=2。
 *   2. 累加权重 (Step b):
 *      代码 `if (i)` 判断为真。
 *      res += dist[2] (0 + 10 = 10)。
 *      解释：这一步意味着我们决定修 "1-2" 这条路，把 2号点拉进电网。
 *      标记 st[2] = true。
 *   3. 更新 (Step c):
 *      用 2号点 更新邻居 {3}：
 *      - dist[3] 原来是 20 (靠1号拉)。
 *      - 现在看 2号：g[2][3] = 5。
 *      - dist[3] = min(20, 5) -> 5 (更新成功！靠2号拉更近)。
 *      
 *   --- 第三次循环 (i=2) ---
 *   1. 找点 (Step a):
 *      扫描未连通的点 {3}。dist[3]=5。选 t=3。
 *   2. 累加权重 (Step b):
 *      res += dist[3] (10 + 5 = 15)。
 *      解释：修 "2-3" 这条路。
 *      标记 st[3] = true。
 *   3. 更新 (Step c):
 *      没有未连通点了。
 *      
 *   最终结果：res = 15 (选了 1-2 和 2-3 两条边)。
 * ============================================
 */

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 510, INF = 0x3f3f3f3f;

int n, m;
int g[N][N]; // 稠密图，用邻接矩阵存
int dist[N]; // dist[i] 表示 i 到 "当前生成树集合" 的最短距离
bool st[N];  // st[i] 表示 i 是否已经在生成树集合里了

int prim()
{
    // 1. 初始化距离为无穷大
    memset(dist, 0x3f, sizeof dist);
    
    int res = 0; // 存储最小生成树的所有边的总权重
    
    // 2. 迭代 n 次 (每次拉一个村庄 t 进集合)
    // 为什么循环 n 次？因为要让 n 个点都进集合。
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        
        // --- 步骤a: 寻找下一个 "最近的" 邻居 ---
        // 在所有【未连通 (st==false)】的点中，找一个 dist 最小的点 t
        for (int j = 1; j <= n; j ++ )
        {
            if (!st[j] && (t == -1 || dist[j] < dist[t]))
                t = j;
        }

        // --- 特判图的连通性 ---
        // 如果 i > 0 (不是第一次)，且找到的最近点 t 的距离还是 INF，
        // 说明剩下的点全都连不过来（孤岛），图是不连通的，无法生成树。
        if (i && dist[t] == INF) return INF;

        // --- 步骤b: 累加权重 ---
        // 【关键逻辑解释：为什么要 if(i)】
        // i=0 时：
        //   t 是我们选的第一个点(种子/起点)。
        //   dist[t] 是初始值(比如0x3f3f3f3f)，或者是0，但这不代表一条边。
        //   起点的加入是不需要花费"边权"的，它自己就是发源地。
        //   所以 i=0 时不能 res += dist[t]。
        // i>0 时：
        //   t 是通过某条最短的边(长度dist[t])被拉进集合的。
        //   所以我们要支付这条边的成本，res += dist[t]。
        if (i) res += dist[t];
        
        st[t] = true; // 标记：t 点正式进入集合

        // --- 步骤c: 用新人 t 去更新其他人 ---
        // t 进来了，看它能不能把剩下的未连通节点拉得更近一点？
        // 比如 j 之前离集合距离是 dist[j]，
        // 现在看：j 离 t 的距离 g[t][j] 是不是更小？如果是，就更新。
        // 
        // 这里的 min 是关键：Prim 只关心“连上集合的最短边”，不累加路径长。
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], g[t][j]);
    }
    
    return res;
}

int prim() {
    memset(dist, 0x3f, sizeof dist);
    int res = 0;
    for(int i = 0; i < n; i ++ ) {
        int t = -1;
        for(int j = 1; j <= n; j ++ ) {
            if(!st[j] && (t == -1 || dist[j] < dist[t])){
                t = j;
            }
        }

        if(i && dist[t] == INF) return INF;
        if(i) res += dist[t];
        st[t] = true;

        for(int j = 1; j <= n; j ++ ) {
            dist[j] = min(dist[j], g[t][j]);
        }
    }
    return res;
}

int main()
{
    // 输入点数和边数
    cin >> n >> m;

    // 初始化邻接矩阵
    memset(g, 0x3f, sizeof g);

    while (m -- )
    {
        int u, v, w;
        cin >> u >> v >> w;
        // 无向图：存两条边
        // 虽然题目可能给有向边数据，但最小生成树通常是针对无向图定义的
        // 如果题目说是无向图，要在两个方向都存，且处理重边取最小值
        g[u][v] = g[v][u] = min(g[u][v], w);
    }

    int t = prim();

    if (t == INF) puts("impossible");
    else printf("%d\n", t);

    return 0;
}
