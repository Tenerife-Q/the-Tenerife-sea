/*
 * 综合练习题1：迷宫救援 (Maze Rescue)
 * 难度：⭐⭐⭐
 * 
 * 【题目描述】
 * 一个 R x C 的迷宫。
 * 'S': 起点
 * 'E': 终点
 * '.': 空地
 * '#': 墙壁
 * 'a'-'e': 钥匙 (捡起后可以打开对应的门)
 * 'A'-'E': 门 (必须有对应的钥匙才能通过)
 * 
 * 求从起点走到终点的最少步数。如果无法到达，输出 -1。
 * 
 * 【算法思路：BFS + 状态压缩】
 * 普通的 BFS 状态是 (x, y)。
 * 但这里如果只记录 (x, y)，可能会出现：
 * 你走到了 (x, y) 面前是一个门 A，你没钥匙。你得回去找钥匙 a，然后再回来。
 * 如果只记录 visited[x][y]，那么你回去的路就被标记为"已访问"，走不通了。
 * 
 * 所以状态必须包含"你手里有哪些钥匙"。
 * 用一个整数 mask (二进制) 表示钥匙状态。
 * 第 0 位为 1 表示有钥匙 a，第 1 位为 1 表示有钥匙 b...
 * 
 * state: (x, y, key_mask)
 * dist[x][y][key_mask]: 记录在该状态下的最小步数。
 * 
 * 队列元素: struct Node { int x, y, mask; }
 * 
 * 转移规则：
 * 1. 遇到 '.': dist[nx][ny][mask] = dist[x][y][mask] + 1
 * 2. 遇到 'a'-'e': 新状态 mask | (1 << (char - 'a'))
 * 3. 遇到 'A'-'E': 检查 mask & (1 << (char - 'A')) 是否为真。是则通行，否则不能走。
 */

#include <iostream>
#include <queue>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 55;
char g[N][N];
int dist[N][N][1 << 5]; // 最多5把钥匙 a-e
int R, C;

struct Node {
    int x, y, mask;
};

int dx[4] = {-1, 0, 1, 0};
int dy[4] = {0, 1, 0, -1};

int bfs(int sx, int sy, int ex, int ey) {
    memset(dist, -1, sizeof dist);
    queue<Node> q;
    
    // 初始状态：(sx, sy, 0)
    q.push({sx, sy, 0});
    dist[sx][sy][0] = 0;

    while (q.size()) {
        Node t = q.front();
        q.pop();

        if (t.x == ex && t.y == ey) return dist[t.x][t.y][t.mask];

        for (int i = 0; i < 4; i++) {
            int nx = t.x + dx[i];
            int ny = t.y + dy[i];

            if (nx < 0 || nx >= R || ny < 0 || ny >= C) continue;
            char c = g[nx][ny];
            if (c == '#') continue;

            // 计算新的 mask (默认和原来一样，除非捡到钥匙)
            int next_mask = t.mask;

            // 1. 遇到门
            if (c >= 'A' && c <= 'E') {
                int door_id = c - 'A';
                if (! (t.mask >> door_id & 1)) continue; // 没钥匙，过不去
            }
            // 2. 遇到钥匙
            else if (c >= 'a' && c <= 'e') {
                int key_id = c - 'a';
                next_mask = t.mask | (1 << key_id);
            }

            // 更新距离
            if (dist[nx][ny][next_mask] == -1) {
                dist[nx][ny][next_mask] = dist[t.x][t.y][t.mask] + 1;
                q.push({nx, ny, next_mask});
            }
        }
    }
    return -1;
}

/*
int bfs(int sx, int sy, int ex, int ey) {
    // 初始化距离表：全部填 -1，代表"未探索区域"
    memset(dist, -1, sizeof dist);
    queue<Node> q;
    q.push({sx, sy, 0});
    dist[sx][sy][0] = 0;

    while(q.size()) {
        // 取出队头元素
        Node t = q.front();
        q.pop();
        // 如果到达终点，返回距离
        if(t.x == ex && t.y == ey){
            return dist[t.x][t.y][t.mask];
        }
        // 向四个方向扩散
        for(int i = 0; i < 4; i++ ) {
            int nx = t.x + dx[i];
            int ny = t.y + dy[i];
            // 越界检查
            if(nx < 0 || nx >= R || ny < 0 || ny >= C) {
                continue;
            }
            char c = g[nx][ny];
            // 墙壁检查
            if(c == '#') {
                continue;
            }
            // 计算新的钥匙状态
            int next_mask = t.mask;
            if(c >= 'A' && c <= 'E') {
                int door_id = c -'A';
                if(t.mask >> door_id & 1) {
                    // 有钥匙，能过门
                } else {
                    // 没钥匙，过不去
                    continue;
                }
            }
            else if(c >= 'a' && c <= 'e') {
                int key_id = c - 'a';
                next_mask = t.mask | (1 << key_id);
            }
            // 更新距离表和入队
            if(dist[nx][ny][next_mask] == -1) {
                dist[nx][ny][next_mask] = dist[t.x][t.y][t.mask] + 1;
                q.push({nx, ny, next_mask});
            }
        }
    }
    return -1;
}
*/


int main() {
    cin >> R >> C;
    int sx, sy, ex, ey;

    for (int i = 0; i < R; i++) {
        cin >> g[i]; // 读入一行字符串
        for (int j = 0; j < C; j++) {
            if (g[i][j] == 'S') {
                sx = i, sy = j;
            } else if (g[i][j] == 'E') {
                ex = i, ey = j;
                g[i][j] = '.'; // 把终点视为可行走的空地, 方便处理
            }
        }
    }

    /*
     * 测试输入:
     * 5 5
     * S...A
     * .###.
     * .a#..
     * ###..
     * ....E
     * 
     * 门 A 需要钥匙 a。钥匙 a 在 (2, 1)。
     * 路径：S(0,0) -> (2,0) -> a(2,1)捡钥匙 -> 返回(0,0) -> 门A(0,4) -> E
     */

    cout << bfs(sx, sy, ex, ey) << endl;

    return 0;
}



/*
 * ==================================================================================
 * 【详细解析：BFS + 状态压缩的核心逻辑】
 * ==================================================================================
 * 
 * 1. 为什么必须使用三维数组 dist[N][N][state]？
 *    -------------------------------------------------------------------------------
 *    - 问题核心：同一个坐标 (x, y)，我们可能需要走多次。
 *      举例：第一次到 (2,2) 没钥匙，被门挡住；去别处捡了钥匙后，再次回到 (2,2)，这次就能通过了。
 *    - 状态区分：
 *      单纯的 visited[x][y] 无法区分"有没有钥匙"这两种情况。
 *      因此必须把"手里的钥匙状态"作为第三个维度：dist[x][y][mask]。
 *    - 优势：
 *      (1) 区分旧地重游：(2,2,无钥匙) 和 (2,2,有钥匙) 被视为两个完全不同的节点。
 *      (2) 避免死循环：虽然可以回头，但钥匙状态只有 32 种 (2^5)，状态总数有限 (50*50*32)，保证 BFS 会结束。
 *      (3) 最优解保证：BFS 的层序遍历性质保证了第一次到达某状态时，步数一定最少。
 * 
 * 2. 数学与二进制运算详解
 *    -------------------------------------------------------------------------------
 *    我们用一个整数 mask 的二进制位来表示 5 把钥匙：
 *    - 第 0 位：钥匙 'a'
 *    - 第 1 位：钥匙 'b'
 *    ...
 *    
 *    (A) 捡起钥匙 (按位或 | )
 *        场景：当前状态 mask，捡到钥匙 'c' (对应 ID=2)
 *        代码：next_mask = mask | (1 << 2);
 *        解释：
 *        - (1 << 2) = 00100 (二进制)
 *        - mask | 00100：不管 mask 原来第 2 位是 0 还是 1，强制把它变成 1。
 * 
 *    (B) 检查能否开门 (按位与 & )
 *        场景：遇到门 'C' (对应 ID=2)，检查是否有钥匙
 *        代码：if ( ! (mask >> 2 & 1) ) continue;
 *        解释：
 *        - mask >> 2：把第 2 位移到最右边 (第 0 位)。
 *        - & 1：检查最右边那一位。如果是 1 (真) 说明有钥匙，0 (假) 说明没有。
 * 
 * 3. BFS 方向顺序与不走回头路
 *    -------------------------------------------------------------------------------
 *    (A) 为什么是 dx = {-1, 0, 1, 0} (上右下左)？
 *        - 为了方便循环，把 4 个方向的坐标变化存入数组。
 *        - 顺序无关紧要：BFS 像水波纹扩散，无论先往哪个方向扩，第 N 层的节点一定是在第 N 步被遍历到。
 *          顺序只会影响在有多条最短路时，你先找到哪一条的特定形状，但不影响"最少步数"这个数值。
 * 
 *    (B) 如何防止死循环 (不走回头路)？
 *        - 依靠 dist 数组判重：if (dist[nx][ny][next_mask] == -1)
 *        - 逻辑：
 *          如果你在 (x,y) 没捡到新钥匙，mask 没变。回头走会遇到 dist[px][py][mask]，这个状态肯定已经访问过了 (dist != -1)，
 *          所以会被跳过。
 *          但如果你捡到了新钥匙，mask 变了。回头走遇到 dist[px][py][new_mask]，这个新状态是 -1 (未访问)，
 *          所以允许你带着新钥匙走回老地方。
 * 
 * 4. 纠正误区：队列 (Queue) vs 栈 (Stack)
 *    -------------------------------------------------------------------------------
 *    (重要) 误区点拨：
 *    "是不是队列里只有一个元素？前一个 push 进去，下一步直接 pop 出来？"
 *    -> 这完全不对！这是 DFS (栈/递归) 的特征，绝不是 BFS。
 * 
 *    BFS 队列的真实形态 (像涟漪一样扩张)：
 *    1. 虽然每次循环开头只 pop 出来 1 个元素 (t)，
 *    2. 但在 for 循环里，这个 t 可能会向四周扩散，产生 0 到 4 个新邻居。
 *    3. 这些新邻居会全部被 push 进队列队尾！
 *    
 *    例子：
 *    - 此时队列：[A]
 *    - pop A，A 发现周围有 B, C, D 三个空地。
 *    - push B, push C, push D。
 *    - 此时队列：[B, C, D]  (一下子变多了！)
 *    - 下次循环 pop B，B 可能又发现 E, F...
 *    
 *    结论：队列里通常存着"当前层"的所有节点（比如所有离起点 3 步的点）。
 *    它绝对不是"进一个出一个"的线性结构，而是"爆发式"增长的缓冲区。
 *    这也是为什么 BFS 能找到最短路 —— 因为它齐头并进，像水波一样同时覆盖所有方向。
 * ==================================================================================
 */

