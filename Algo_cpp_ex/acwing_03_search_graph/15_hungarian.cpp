/*
 * ============================================
 *   匈牙利算法 (Hungarian Algorithm) - 二分图最大匹配
 *   时间复杂度：O(N * M) (实际运行非常快，远小于理论值)
 *   
 *   【什么是最大匹配？】
 *   给定一个二分图 (男生一堆，女生一堆)，每条边代表两个人互相有好感。
 *   匹配：不能重婚！每个人只能找一个对象。
 *   目标：撮合尽可能多的情侣。
 *   
 *   【算法核心思想：各种"腾地"】
 *   "找对象，没合适的就抢！抢了再让原来的换一个！"
 *   
 *   流程 (遍历每个男生)：
 *   1. 对于每个男生 u，依次看他所有有好感的女生 v。
 *   2. 如果女生 v 还没男朋友 (match[v] == 0) -> 那就成全这对！
 *   3. 如果女生 v 已经有男朋友了 (match[v] != 0) -> 看看能不能让她的现任男友找个新的？
 *      - 尝试让现任男友"腾地" (find(match[v]))。
 *      - 如果现任男友能找到备胎，那他就去跟备胎好，把 v 让给我！
 *      - 否则，这个男生 u 只能找下一个女生试试。
 *   
 *   【关键】
 *   st[v] 数组的作用：
 *   每一轮 match(u) 都要清空 st。
 *   表示"在这一次帮 u 找对象的过程中，v 这个女生已经被预定过了，别老盯着这同一个女生看"。
 * ============================================
 */

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 510, M = 100010;

int n1, n2, m; // n1:左部点数(男生), n2:右部点数(女生), m:边数
int h[N], e[M], ne[M], idx; // 只需要存一边(男生->女生)的边
int match[N]; // 右部点(女生)目前的匹配对象是谁。match[v]=u 表示女生v的男友是u
bool st[N];   // 每次帮某个男生找对象时，记录哪些女生已经被考虑过了 (防止递归死循环)

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 尝试给男生 u 找个对象
// 返回值：是否成功匹配
bool find(int u)
{
    // 遍历所有该男生有好感的女生
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        
        // 如果这个女生在这轮递归中还没被预定
        if (!st[j])
        {
            st[j] = true; // 好的，我(或者我的上级)正在尝试染指这个女生
            
            // 核心逻辑：
            // 1. 如果这个女生没有对象 (match[j] == 0) -> 那就归我！
            // 2. 如果这女生有对象 (match[j] != 0)，那就让她的现任男友 (match[j]) 去找别的备胎
            //    如果现任男友能找到新对象 (find(match[j]))，那就把这个女生让给我！
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = u; // 匹配成功！女生 j 的男友现在是 u
                return true;
            }
        }
    }
    return false; // 找了一圈都没戏
}

int main()
{
    scanf("%d%d%d", &n1, &n2, &m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int u, v;
        scanf("%d%d", &u, &v);
        // 虽然可能是无向图含义，但匈牙利算法只需要存 从左部 指向 右部 的有向边即可。
        // 因为我们总是从左部点出发去找右部点。
        add(u, v);
    }

    int res = 0; // 记录总共撮合了多少对
    
    // 遍历每一个男生
    for (int i = 1; i <= n1; i ++ )
    {
        // 每次开始新一轮撮合，都要重置 st 数组
        // 因为上一轮我不追的女生，这一轮可能我想追，且不冲突了
        // 或者上一轮虽然被预订了但那是为了别人，这轮为了我重新预定
        memset(st, false, sizeof st);
        
        // 如果这个男生找到了对象，总数+1
        if (find(i)) res ++ ;
    }

    printf("%d\n", res);

    return 0;
}
