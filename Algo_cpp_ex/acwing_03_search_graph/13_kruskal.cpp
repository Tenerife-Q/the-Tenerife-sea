/*
 * ============================================
 *   Kruskal 算法 (克鲁斯卡尔算法) - 最小生成树
 *   时间复杂度：O(M log M) (排序决定了瓶颈)
 *   
 *   【核心概念解析】
 *   1. 最小生成树 (MST)：
 *      - 在一个 N 个点的连通图中，选出 N-1 条边。
 *      - 选出的边必须把所有点连在一起（生成树）。
 *      - 选出的边权之和必须最小（最小）。
 * 
 *   2. Kruskal 算法 (加边法)：
 *      - 贪心策略：既然想要总权重最小，那我每次都只挑“当前最便宜”的那条边！
 *      - 流程：
 *        a. 把所有边按权重从小到大排序。
 *        b. 从最便宜的边开始拿。
 *        c. 如果这条边的两个端点原本是不连通的 -> 拿！(连上)
 *        d. 如果这两个端点已经连通了 -> 丢！(再连就成环了，浪费钱)
 * 
 *   3. 并查集 (Union-Find) & 递归：
 *      - 作用：快速判断两个点是不是在同一个集合里（是否已经连通）。
 *      - 核心：`find(x)` 函数。
 *      - 递归：`find(x)` 会不断找爸爸，直到找到祖宗。
 *      - 路径压缩：找祖宗的路上，把沿途所有人的爸爸直接改成祖宗，下次找就快了。
 * ============================================
 */

#include <iostream>
#include <algorithm>

using namespace std;

// N 是点的最大数量，M 是边的最大数量
// Kruskal 适合稀疏图，通常 M 和 N 差不多大，或者 M 是 N 的几倍
const int N = 200010; 
const int M = 100010; 

int n, m;           // n: 点数, m: 边数
int p[N];           // 并查集数组 (Parent)，p[x] 存的是 x 的父节点

// 【结构体 Edge：为什么要这样写？】
// 1. 为什么不用三个数组 a[], b[], w[]？
//    因为排序时，如果 separate sort，w[] 变了顺序，a[]和b[]跟不上，数据就乱了。
//    用 struct 把 a, b, w 捆绑在一起，sort 移动时是"整条边"一起移动。
// 2. 为什么需要重载 operator< ？
//    std::sort 默认只知道怎么排 int, double。它不知道怎么排 Edge。
//    这是 C++ 的语法糖：告诉 sort，当我比较两个 Edge 时，其实是比较它们的权重 w。
//    (const Edge &W) 是引用传递，避免拷贝结构体，const 表示我不修改它。
struct Edge
{
    int a, b, w;

    // 【重载小于号 operator<】
    // 作用：告诉 C++ 的 sort 函数，两个 Edge 结构体谁大谁小。
    // 逻辑：我们希望按权重 w 从小到大排序，所以 return w < W.w。
    bool operator< (const Edge &W) const
    {
        return w < W.w;
    }
} edges[M]; // 声明一个边的数组，用来存所有的边

/*
 * ============================================
 *   【关键算法模块：并查集原理深度解析】
 *   
 *   Q: 并查集明明是用数组 p[] 存的，为什么说它是一棵树？
 *   A: 数组 p[i] 隐式地定义了父子关系。p[i] = father。
 *      我们可以通过 p[i] 顺藤摸瓜找到爷爷、祖宗。
 * 
 *   【图解演示：合并与压缩】
 *   初始状态：p[1]=1, p[2]=2, p[3]=3 (三棵树，三个光杆司令)
 * 
 *   1. 执行 p[1] = 2 (1认2做父):
 *         2 (root)
 *        /
 *       1
 * 
 *   2. 执行 p[2] = 3 (2认3做父):
 *           3 (root)
 *          /
 *         2
 *        /
 *       1
 *      此时树结构形成了！1->2->3。
 * 
 *   3. 此时调用 find(1) 发生了什么？(路径压缩)
 *      - find(1) 发现 p[1]=2 (不是根)，去问 find(2)。
 *      - find(2) 发现 p[2]=3 (不是根)，去问 find(3)。
 *      - find(3) 发现 p[3]=3 (是根！)，返回 3。
 *      - 回溯到 find(2)，执行 p[2]=3 (没变)，返回 3。
 *      - 回溯到 find(1)，执行 p[1]=3 (【关键！】直接把1连到3下面)，返回 3。
 * 
 *      【压缩后的树结构】：
 *           3 (root)
 *          / \
 *         1   2
 *      下次再查 find(1)，一步就找到 3 了，效率极大提升！
 * ============================================
 */
// 并查集核心函数：find
int find(int x)
{
    // 如果 x 的父节点 p[x] 不是 x 自己，说明 x 不是祖宗
    if (p[x] != x) 
    {
        // 递归调用：去找爸爸的爸爸...直到找到祖宗
        // 路径压缩：回溯时，直接把 x 的父节点设为祖宗。
        // 比如原本是 x -> father -> grandpa -> root
        // 跑完这行变成 x -> root. 下次再查 x 就只要 O(1) 了。
        p[x] = find(p[x]);
    }
    return p[x]; // 返回祖宗
}

int main()
{
    scanf("%d%d", &n, &m);

    // 读入 m 条边
    for (int i = 0; i < m; i ++ )
    {
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        edges[i] = {a, b, w}; // 用结构体存边
    }

    // 【关键步骤 1：排序】
    // 贪心的基础！要把最便宜的边排在前面。
    // 这里会自动调用结构体里的 operator<
    sort(edges, edges + m);

    // 【关键步骤 2：初始化并查集】
    // 一开始，每个点都是独立的集合，自己的父节点是自己。
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    int res = 0; // 存储结果：最小生成树的边权总和
    int cnt = 0; // 计数器：记录一定要选几条边 (理论上需要 n-1 条)

    // 【关键步骤 3：枚举每一条边】
    // 已经被 sort 排好序了，所以是从小到大枚举
    for (int i = 0; i < m; i ++ )
    {
        // 取出当前这条边的信息
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        // 【并查集查询】
        // 找 a 的祖宗 fa，找 b 的祖宗 fb
        int fa = find(a);
        int fb = find(b);

        // 如果 fa != fb，说明 a 和 b 目前不在同一个集合里
        // 也就是说：这是一条连接两个“不同独立团伙”的桥梁！
        // 既然它是连接这两个团伙的边里权重最小的（因为由于排序，大的还在后面），当然要选它！
        if (fa != fb)
        {
            p[fa] = fb; // 【合并】：把 a 的祖宗认 b 的祖宗做父节点（两个集合合并）
            res += w;   // 把这条边的权重加入总花费
            cnt ++ ;    // 选中了一条边
        }
        // 如果 fa == fb，说明 a 和 b 早就连通了（可能是通过其他更短的边连上的），
        // 再连这条边就会形成环，所以直接跳过（implied continue）。
    }

    // 【收尾判断】
    // 最小生成树必须要有 n-1 条边才能把 n 个点全连起来。
    // 如果 cnt < n - 1，说明图本身就是断开的，连不通。
    if (cnt < n - 1) puts("impossible");
    else printf("%d\n", res);

    return 0;
}
