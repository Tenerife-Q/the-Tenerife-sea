/*
 * ============================================
 *   DFS (深度优先搜索) - 数字全排列
 *   核心思想：一条路走到黑，撞墙回溯 (Backtracking)
 * ============================================
 * 
 * 【物理模型：走迷宫的勇士】
 *   勇士手里拿着几个数字牌（1~n），面前有n个空位（u）。
 *   勇士的策略是：
 *   1. 站在第 u 个空位前，手里还有哪些数字没用过？
 *   2. 挑一个没用过的数字填进去。
 *   3. 继续往下一个空位 (u+1) 走。
 *   4. 如果走到头了 (u > n)，说明填满了一行，赶紧记下来（输出）。
 *   5. 【回溯关键】如果这条路走不通或者走完了，退回上一步，把刚才填进去的数字拿回来（恢复现场），
 *      然后尝试填手里剩下的其他数字。
 * 
 * 【数据结构映射】
 *   - path[N]: 记录当前路径上填的数字。
 *     物理含义：勇士走过的脚印。
 * 
 *   - st[N] (bool state): 记录哪些数字已经被用过了。
 *     物理含义：手里的数字牌，true表示牌已经用掉了，false表示还在手里。
 * 
 * 【时间复杂度】
 *   全排列的时间复杂度是 O(n * n!)。因为有 n! 种排列，每种排列输出需要 O(n)。
 *   DFS 极其依赖剪枝，但在最坏情况下就是指数级。
 */

#include <iostream>

using namespace std;

const int N = 10;

int n;
int path[N]; // 存储当前排列路径
bool st[N];  // state，记录数字是否被使用过 (true: 已用, false: 未用)

// u: 当前枚举到了第几个位置 (层数)
void dfs(int u)
{
    // 【边界条件】
    // 如果已经填完了 n 个位置 (u 从 1 到 n)
    if (u > n)
    {
        for (int i = 1; i <= n; i ++ ) printf("%d ", path[i]);
        puts(""); // 换行
        return;
    }

    // 【枚举过程】
    // 在当前位置 u，尝试填入数字 1 到 n
    for (int i = 1; i <= n; i ++ )
    {
        // 如果数字 i 没有被使用过
        if (!st[i])
        {
            path[u] = i;    // 1. 填数：把 i 填入当前位置 u
            st[i] = true;   // 2. 标记：数字 i 已被占用
            
            dfs(u + 1);     // 3. 递归：进入下一层 (下一个位置)

            // 【回溯核心】
            // 当 dfs(u+1) 执行完退回来时，说明子树遍历完毕，
            // 需要恢复现场，以便在当前位置 u 尝试下一个数字 (i+1)。
            st[i] = false;  // 4. 恢复：把数字 i 释放出来
            path[u] = 0;    // (可选) 逻辑上path[u]会被覆盖，不写也没事，但写了逻辑更严谨
        }
    }
}

int main()
{
    // 即使n较小，DFS的威力也很大，通常 n <= 9
    cin >> n;

    // 从第 1 个位置开始搜索
    dfs(1);

    return 0;
}

/*
 * ============================================
 *   【深度解析：如何不把自己绕晕？】
 *   很多初学者觉得递归很难，是因为试图在脑子里模拟计算机的一步步执行。
 *   但这就像试图用人脑跑汇编一样，肯定会晕。
 *   
 *   这里提供两个思维模型，让你一眼看穿递归：
 * 
 *   模型一：主管与临时工模型 (The Manager Model)
 *   --------------------------------------------
 *   想象你是一个主管 (dfs(u))，你的任务是搞定第 u 个位置。
 *   你手下有一帮临时工 (dfs(u+1))。
 *   
 *   你的工作流程：
 *   1. 【Check】：我看一眼手里还有哪些数字牌没用过？(for i = 1 to n)
 *   2. 【Do】：我看上了数字 1，我把它贴到第 u 个空位上。(path[u] = 1, st[1] = true)
 *   3. 【Delegate】：剩下的空位我不归我管，我要喊下一个主管来。(dfs(u+1))
 *      - 关键点：这一步你只需要相信下一个主管能把剩下的事办好，不需要管他怎么办。
 *      - 这一步相当于你把工作交接出去了，你可以去喝茶了，直到他回来汇报工作。
 *   4. 【Undo】：下一个主管回报说“老板，我这分支的所有情况都试完了”。
 *      这时候你必须把你贴的数字 1 撕下来，放回牌堆。(st[1] = false)
 *      为什么？因为你要试下一个数字 2 了，如果不把 1 放回去，下次就没法用了。
 * 
 *   模型二：n=3 的完整执行流 (用于详细复盘)
 *   --------------------------------------------
 *   (为了简洁，p代表path数组状态，st代表被占用的数字集合)
 * 
 *   1. 【dfs(1) 开始】: u=1
 *      - i=1 available. 填1. (p=[1], st={1}) -> 呼叫 dfs(2)
 * 
 *      2. 【dfs(2) 开始】: u=2
 *         - i=1 used. 跳过.
 *         - i=2 available. 填2. (p=[1,2], st={1,2}) -> 呼叫 dfs(3)
 * 
 *         3. 【dfs(3) 开始】: u=3
 *            - i=1 used. 跳过.
 *            - i=2 used. 跳过.
 *            - i=3 available. 填3. (p=[1,2,3], st={1,2,3}) -> 呼叫 dfs(4)
 * 
 *            4. 【dfs(4) 开始】: u=4 > n
 *               - !!! 打印输出 "1 2 3" !!!
 *               - return 回到 dfs(3)
 * 
 *            (回到 dfs(3))
 *            - i=3 的分支跑完了. 
 *            - 【回溯】st[3]=false. (3号被释放).
 *            - 循环 i 结束.
 *            - return 回到 dfs(2)
 * 
 *         (回到 dfs(2))
 *         - i=2 的分支跑完了.
 *         - 【回溯】st[2]=false. (2号被释放).
 *         - i=3 available. 填3. (p=[1,3], st={1,3}) -> 呼叫 dfs(3)
 * 
 *         3. 【dfs(3) 开始】: u=3 (注意这次是在第2层填了3的情况下)
 *            - i=1 used. 跳过.
 *            - i=2 available. 填2. (p=[1,3,2], st={1,3,2}) -> 呼叫 dfs(4)
 * 
 *            4. 【dfs(4) 开始】: u=4 > n
 *               - !!! 打印输出 "1 3 2" !!!
 *               - return 回到 dfs(3)
 * 
 *            (回到 dfs(3))
 *            - i=2 的分支跑完了.
 *            - 【回溯】st[2]=false. (2号被释放).
 *            - i=3 used. 跳过.
 *            - 循环 i 结束.
 *            - return 回到 dfs(2)
 * 
 *         (回到 dfs(2))
 *         - i=3 的分支跑完了.
 *         - 【回溯】st[3]=false. (3号被释放).
 *         - 循环 i 结束.
 *         - return 回到 dfs(1)
 * 
 *      (回到 dfs(1))
 *      - i=1 的分支跑完了.
 *      - 【回溯】st[1]=false. (1号被释放).
 *      - i=2 available. 填2. (p=[2], st={2}) -> 呼叫 dfs(2)
 *      
 *      ... (接下来就是 2 1 3, 2 3 1 的过程) ...
 * 
 *   【总结】
 *   核心就三句话：
 *   1. 现在的坑填什么？ (for循环)
 *   2. 剩下的坑交给下一个人。 (递归)
 *   3. 这一轮试完了，把坑腾出来给下一轮。 (回溯)
 * ============================================
 */
