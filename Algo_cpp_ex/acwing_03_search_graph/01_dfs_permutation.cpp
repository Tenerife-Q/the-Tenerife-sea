/*
 * ============================================
 *   DFS (深度优先搜索) - 数字全排列
 *   核心思想：一条路走到黑，撞墙回溯 (Backtracking)
 * ============================================
 * 
 * 【物理模型：走迷宫的勇士】
 *   勇士手里拿着几个数字牌（1~n），面前有n个空位（u）。
 *   勇士的策略是：
 *   1. 站在第 u 个空位前，手里还有哪些数字没用过？
 *   2. 挑一个没用过的数字填进去。
 *   3. 继续往下一个空位 (u+1) 走。
 *   4. 如果走到头了 (u > n)，说明填满了一行，赶紧记下来（输出）。
 *   5. 【回溯关键】如果这条路走不通或者走完了，退回上一步，把刚才填进去的数字拿回来（恢复现场），
 *      然后尝试填手里剩下的其他数字。
 * 
 * 【数据结构映射】
 *   - path[N]: 记录当前路径上填的数字。
 *     物理含义：勇士走过的脚印。
 * 
 *   - st[N] (bool state): 记录哪些数字已经被用过了。
 *     物理含义：手里的数字牌，true表示牌已经用掉了，false表示还在手里。
 * 
 * 【时间复杂度】
 *   全排列的时间复杂度是 O(n * n!)。因为有 n! 种排列，每种排列输出需要 O(n)。
 *   DFS 极其依赖剪枝，但在最坏情况下就是指数级。
 */

#include <iostream>

using namespace std;

const int N = 10;

int n;
int path[N]; // 存储当前排列路径
bool st[N];  // state，记录数字是否被使用过 (true: 已用, false: 未用)

// u: 当前枚举到了第几个位置 (层数)
void dfs(int u)
{
    // 【边界条件】
    // 如果已经填完了 n 个位置 (u 从 1 到 n)
    if (u > n)
    {
        for (int i = 1; i <= n; i ++ ) printf("%d ", path[i]);
        puts(""); // 换行
        return;
    }

    // 【枚举过程】
    // 在当前位置 u，尝试填入数字 1 到 n
    for (int i = 1; i <= n; i ++ )
    {
        // 如果数字 i 没有被使用过
        if (!st[i])
        {
            path[u] = i;    // 1. 填数：把 i 填入当前位置 u
            st[i] = true;   // 2. 标记：数字 i 已被占用
            
            dfs(u + 1);     // 3. 递归：进入下一层 (下一个位置)

            // 【回溯核心】
            // 当 dfs(u+1) 执行完退回来时，说明子树遍历完毕，
            // 需要恢复现场，以便在当前位置 u 尝试下一个数字 (i+1)。
            st[i] = false;  // 4. 恢复：把数字 i 释放出来
            path[u] = 0;    // (可选) 逻辑上path[u]会被覆盖，不写也没事，但写了逻辑更严谨
        }
    }
}

int main()
{
    // 即使n较小，DFS的威力也很大，通常 n <= 9
    cin >> n;

    // 从第 1 个位置开始搜索
    dfs(1);

    return 0;
}
