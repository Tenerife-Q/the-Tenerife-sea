/*
 * ============================================
 *   Floyd 算法 (Floyd-Warshall) - 多源最短路
 *   时间复杂度：O(N^3)
 *   
 *   【核心原理：动态规划】
 *   状态：d[i][j] 表示从 i 到 j 的最短距离。
 *   转移：我们尝试找一个中间人 k。
 *        "如果我们不仅仅直达，而是允许经过第 k 号点中转，路会不会变短？"
 *        d[i][j] = min(d[i][j], d[i][k] + d[k][j])
 * 
 *   【记忆口诀】
 *   "三层循环，k 在最外层。"
 *   (i, j 是起点和终点，k 是那个尝试插进来的中间人)
 * 
 *   【算法流程模拟】
 *   假设有 3 个点，初始距离如下 (INF代表不通)：
 *       1   2   3
 *   1   0   2   9 (1->3是很远的路, 9)
 *   2   2   0   1 (2->3是很近的路, 1)
 *   3   9   1   0
 * 
 *   第一轮循环 (k=1)：允许经过 1号点 中转
 *   - d[2][3] = min(d[2][3], d[2][1] + d[1][3]) = min(1, 2+9=11) -> 还是 1
 *     (经过 1号点 反而绕远了，不更新)
 * 
 *   第二轮循环 (k=2)：允许经过 2号点 中转
 *   - d[1][3] 本来是 9 (直达)
 *   - 现在的中转方案：d[1][2] + d[2][3] = 2 + 1 = 3
 *   - d[1][3] 更新为 3！ (1 -> 2 -> 3 比 1 -> 3 快多了)
 * 
 *   第三轮循环 (k=3)：允许经过 3号点 中转
 *   - ... 检查所有点对 ...
 * 
 *   结束后，d[i][j] 就是全局最短路。
 * 
 * 
 * 输入输出示例：
 *  3 3 2
    1 2 2
    2 3 3
    1 3 10
    1 3
    2 3
    输出：
    5
 * ============================================
 */

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 210, INF = 1e9;

int n, m, Q; // Q: 询问次数
int d[N][N]; // 邻接矩阵：因为 N 比较小 (200左右)，可以直接存

void floyd()
{
    // [核心代码]
    // 只有短短 5 行，背下来！
    // 注意：k (中间人) 必须放在最外层循环！
    // 意义：第一轮 k=1，表示允许经过 1号点 中转。
    //      第二轮 k=2，表示允许经过 1,2号点 中转...
    //      直到 k=n，表示允许经过所有点中转，这就是最终的最短路。
    
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

int main()
{
    scanf("%d%d%d", &n, &m, &Q);

    // [初始化]
    // 自己到自己距离是0，到别人是无穷大
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

    // [读入边]
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        
        // 【关键点：处理重边】
        // 比如输入给了两条 1->2 的边，一条长 5，一条长 3。
        // 我们只需要保留 3 即可。所以用 min 更新。
        // 自环通常是 0，不用管，除非题目有正权自环一般也不影响最短路。
        d[a][b] = min(d[a][b], c);
    }

    // [计算]
    floyd();

    // [处理询问]
    while (Q -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);

        // 如果 d[a][b] 还是很大（哪怕被减去了一点负权边），说明不可达
        if (d[a][b] > INF / 2) puts("impossible");
        else printf("%d\n", d[a][b]);
    }

    return 0;
}
