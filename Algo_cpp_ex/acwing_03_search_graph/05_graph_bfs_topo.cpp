/*
 * ============================================
 *   BFS应用 - 拓扑排序 (Topological Sort)
 * ============================================
 * 
 * 【什么是拓扑排序？】
 *   简单说：**把一张乱糟糟的依赖关系网，理成一条线性的执行顺序。**
 *   核心规则：如果图里有一条边 A -> B，那么在排序结果里，A 必须排在 B 前面。
 * 
 * 【图形可视化案例：大学选课】
 * 
 *   假设有 4 门课，依赖关系如下：
 * 
 *       [1. 高数] ----> [3. 离散] ----> [4. 算法]
 *          |                               ^
 *          |                               |
 *          +----------> [2. C++] ----------+
 * 
 *   图解分析：
 *   1. 想修【3.离散】，必须先修【1.高数】。
 *   2. 想修【2.C++】，必须先修【1.高数】。
 *   3. 想修【4.算法】，必须先修【3.离散】和【2.C++】。
 * 
 *   入度表 (In-Degree):
 *   - [1.高数]: 0 (无门槛，直接修)
 *   - [2.C++] : 1 (等高数)
 *   - [3.离散]: 1 (等高数)
 *   - [4.算法]: 2 (等离散、C++)
 * 
 *   【排序执行流程】
 * 
 *   ROUND 1: 扫描全表，谁的入度是 0？
 *   -> 只有 [1.高数]。
 *   -> 进队！ Q = {1}
 *   
 *    ROUND 2: 取出队头 [1.高数]，修完它！
 *   -> 通知高数的后续课程：
 *      - [2.C++] 的依赖减少 1 => 入度变为 0 (解锁!)
 *      - [3.离散] 的依赖减少 1 => 入度变为 0 (解锁!)
 *   -> 谁解锁了？[2] 和 [3]。
 *   -> 进队！ Q = {2, 3} (顺序无所谓)
 * 
 *   ROUND 3: 取出队头 [2.C++]，修完它！
 *   -> 通知 C++ 的后续课程：
 *      - [4.算法] 的依赖减少 1 => 入度变为 1 (还得等离散)。
 *   -> 没新课解锁，继续。
 * 
 *   ROUND 4: 取出队头 [3.离散]，修完它！
 *   -> 通知离散的后续课程：
 *      - [4.算法] 的依赖减少 1 => 入度变为 0 (解锁!)
 *   -> [4] 解锁了。
 *   -> 进队！ Q = {4}
 * 
 *   ROUND 5: 取出队头 [4.算法]。
 *   -> 后面没课了。
 * 
 *   【最终拓扑序列】: 1 -> 2 -> 3 -> 4
 *   (也就是：高数 -> C++ -> 离散 -> 算法)
 * 
 * ============================================
 */

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, m;
// h: 头指针, e: 终点, ne: 下一边, idx: 内存指针
int h[N], e[N], ne[N], idx;
// d: 入度数组 (In-Degree)，存储每个点还有多少条指向它的边
// d[i] = k 表示：想要启动任务 i，必须先完成 k 个前置任务
int d[N];
// q: 队列 (手写 q[hh] 是队头, q[tt] 是队尾)
// 在拓扑排序中，这个队列里存的都是 "已经解锁的任务"(入度为0)
int q[N]; 

// 添加一条有向边 a -> b (a 必须在 b 之前发生)
void add(int a, int b)
{
    e[idx] = b; 
    ne[idx] = h[a]; 
    h[a] = idx ++ ;
}


// 拓扑排序核心逻辑
bool topsort()
{
    int hh = 0, tt = -1; // 队列初始化：hh=0, tt=-1 表示空

    // 1. [海选]: 扫描所有点，把所有起跑线上的点（入度为 0）入队
    // 这些点就像大一新生的必修课，没有任何门槛。
    for (int i = 1; i <= n; i ++ )
    {
        if (d[i] == 0)
        {
            q[ ++ tt] = i; // 入队
        }
    }

    // 2. [循环]: 只要队列不空，就一直处理
    while (hh <= tt)
    {
        // 取出队头 t (这门课我修完了！)
        int t = q[hh ++ ]; 

        // 3. [通知]: 告诉所有依赖 t 的后续课程 j
        // 遍历所有从 t 发出的边: t -> j
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            
            // 核心逻辑: “解锁进度条 + 1”
            // j 的前置任务完成了一个 (t完成)，所以 j 的入度减 1
            d[j] -- ; 
            
            // 如果 j 的所有前置任务都清零了
            if (d[j] == 0)
            {
                // 恭喜 j，你也被解锁了，加入待办列表
                q[ ++ tt] = j; 
            }
        }
    }

    // 4. [判决]: 是否所有点都进入过队列？
    // 如果是个有向无环图 (DAG)，所有点最后都会变成入度0并入队。
    // 如果有环 (Deadlock)，环上的点互相对视，入度永远不会减到 0，永远进不了队列。
    // tt 是队尾指针，从 -1 开始。如果进了 n 个点，tt 应该是 n-1。
    return tt == n - 1;
}
/*
bool topsort() {
    int hh = 0, tt = -1;
    for(int i = 1; i <= n; i ++ ) {
        if(d[i] == 0) q[tt] = i, tt ++ ;
    }
    while (hh <= tt) {
        int t = q[hh];
        hh ++ ;
        for(int i = h[t];i != -1; i = ne[i]) {
            int j = e[i];
            d[j] --;
            if(d[j] == 0) q[tt] = j, tt ++ ;
        }
    }
    return tt == n - 1;
}
*/


int main()
{
    // 初始化邻接表头指针 (别忘了!)
    memset(h, -1, sizeof h);

    cin >> n >> m;

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        cin >> a >> b;
        add(a, b);   // 添加有向边 a -> b 表示 A 是 B 的前置条件
        
        // 【关键】统计入度
        // 既然有一条边指向 b，说明 b 多了一个依赖条件
        d[b] ++ ;    
    }

    // 如果存在拓扑序列，队列 q 中存储的就是结果
    // 因为 q 数组不仅充当队列，还顺便按顺序记录了所有出队的元素！省空间的大师。
    if (topsort())
    {
        // 直接输出队列中的元素，它们就是按拓扑序排列的
        for (int i = 0; i < n; i ++ ) printf("%d ", q[i]);
        puts("");
    }
    else
    {
        puts("-1"); // 存在环，无解 (比如 A->B, B->A 的死锁)
    }

    return 0;
}