/*
 * ============================================
 *   BFS应用 - 拓扑排序 (Topological Sort)
 *   核心思想：依赖关系解除 + 入度为 0 优先
 *   适用场景：任务调度、课程先修、项目管理
 * ============================================
 * 
 * 【物理模型：修学分课程】
 *   大学选课时：
 *   1. 想修“高级图论” (B)，必须先修“算法导论” (A)。
 *      这在图上就是一条有向边：A -> B。
 *   2. B 的入度 (In-degree) 就是必须先修的课程数。
 *   3. 只有当 B 的入度变为 0 时（所有先修课都上完了），你才有资格选 B。
 * 
 *   拓扑排序的过程，就是不断找出“没有任何先修课要求”的课程，修完它，
 *   然后把它的后续课程的入度减 1（相当于解锁了一个条件）。
 * 
 * 【核心数据结构】
 *   1. d[N]: 入度数组 (Degree)。
 *      物理意义：还有多少个先修条件没满足。
 *      d[i] == 0 表示节点 i 已经自由了，可以排进序列。
 * 
 *   2. q[N]: 队列 (Queue)。
 *      物理意义：这就不是简单的 BFS 扩散了，而是“就绪队列”。
 *      只要有点的入度变成 0，立刻把它扔进队列里，等待被处理。
 * 
 *   3. 邻接表 (Adjacency List): 存储图结构。
 *      h[N], e[M], ne[M]: 有向图。
 * 
 * 【重要性质】
 *   1. 有向无环图 (DAG) 一定存在拓扑序列。
 *   2. 如果图中有环 (A -> B -> A)，则这辈子也修不完课，因为互相死锁，入度永远不会减为 0。
 *   3. 拓扑排序可以用来通过“出队数量是否等于 n”来判断图中是否有环。
 */

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, m;
// h: 头指针, e: 终点, ne: 下一边, idx: 内存指针
int h[N], e[N], ne[N], idx;
// d: 入度数组 (in-degree)
int d[N];
// q: 队列 (手写比起 STL queue 更快, q[hh] 是队头, q[tt] 是队尾)
int q[N]; 

// 添加一条有向边 a -> b
void add(int a, int b)
{
    e[idx] = b; 
    ne[idx] = h[a]; 
    h[a] = idx ++ ;
}

// 拓扑排序核心逻辑
bool topsort()
{
    int hh = 0, tt = -1; // 队列初始化：hh=0, tt=-1 表示空

    // 1. 扫描所有点，把所有入度为 0 的点（自由人）入队
    for (int i = 1; i <= n; i ++ )
    {
        if (d[i] == 0)
        {
            q[ ++ tt] = i; // 入队
        }
    }

    // 2. 队列不空时，不断取出队头
    while (hh <= tt)
    {
        int t = q[hh ++ ]; // 取出队头 t

        // 3. 遍历 t 的所有出边 t -> j
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            
            // 核心逻辑：修完了课程 t，那么课程 j 的先修条件就少了一个
            d[j] -- ; 
            
            // 如果 j 的先修条件全部满足了 (入度变为 0)
            if (d[j] == 0)
            {
                q[ ++ tt] = j; // j 也可以入队了
            }
        }
    }

    // 4. 判断是否所有点都进入过队列
    // 如果 tt == n - 1 (队列进出了 n 个点)，说明是一个合法的拓扑序列
    return tt == n - 1;
}

int main()
{
    // 初始化邻接表头指针
    memset(h, -1, sizeof h);

    cin >> n >> m;

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        cin >> a >> b;
        add(a, b);   // 添加有向边 a -> b
        d[b] ++ ;    // b 的入度 + 1 (因为有一条边指向 b)
    }

    // 如果存在拓扑序列，队列 q 中存储的就是结果
    if (topsort())
    {
        // 直接输出队列中的元素，它们就是按拓扑序排列的
        for (int i = 0; i < n; i ++ ) printf("%d ", q[i]);
        puts("");
    }
    else
    {
        puts("-1"); // 存在环，无解
    }

    return 0;
}
