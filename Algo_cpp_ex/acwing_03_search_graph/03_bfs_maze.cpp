/*
 * ============================================
 *   BFS (广度优先搜索) - 走迷宫
 *   题目来源：AcWing 844. 走迷宫
 *   
 *   【题目描述】
 *   给定一个 n × m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1。
 *   0 表示可以走的路，1 表示不可通过的墙壁。
 *   最初，有一个人位于左上角 (1, 1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。
 *   请问，该人从左上角移动至右下角 (n, m) 处，至少需要移动多少次。
 *   数据保证 (1, 1) 处和 (n, m) 处的数字为 0，且一定至少存在一条通路。
 *   
 *   【样例输入】
 *   5 5
 *   0 1 0 0 0
 *   0 1 0 1 0
 *   0 0 0 0 0
 *   0 1 1 1 0
 *   0 0 0 1 0
 *   
 *   【样例输出】
 *   8
 * ============================================
 *   核心思想：水波纹扩散 (Wave Propagation) + 最短路
 * ============================================
 * 
 * 【物理模型：病毒传播 / 水波纹】
 *   假设起点 (0, 0) 有一滴墨水滴入水中。
 *   墨水会向四周扩散：
 *   第 1 秒：扩散到 (0, 1), (1, 0)
 *   第 2 秒：扩散到 (0, 2), (1, 1), (2, 0) ...
 *   
 *   BFS 的本质就是层序遍历。由于墨水是匀速扩散的（每步代价都是1），
 *   所以墨水第一次到达某个点的时间，就是从起点到该点的最短时间。
 *   因此，BFS 天生就能求边权为 1 的图的最短路。
 * 
 * 【核心数据结构】
 *   1. q[N * N]: 队列 (Queue)。
 *      物理意义：当前正在扩散的波锋（边界线）。
 *      hh: 队头 (波锋的内圈)，tt: 队尾 (波锋的外圈)。
 * 
 *   2. d[N][N]: 距离数组 (Distance)。
 *      物理意义：每个点被墨水染色的时间。
 *      初始值为 -1，表示未被染色。
 * 
 *   3. dx[4], dy[4]: 方向向量。
 *      物理意义：墨水只能向 上下左右 四个方向流。
 */

#include <iostream>
#include <algorithm>
#include <cstring>  // memset

using namespace std;

typedef pair<int, int> PII;

const int N = 110;

int n, m;

// 【1. 地图数组 g】
// g[i][j] == 0: 表示是通路，可以走。
// g[i][j] == 1: 表示是墙壁，撞头。
int g[N][N];   

// 【2. 距离/状态数组 d】
// 这是一个"一箭双雕"的数组：
// 作用一：记录从起点(0,0)走到(i,j)花了多少步。
// 作用二：充当"visited"数组。如果 d[i][j] == -1，说明这个点从未到达过。
//         只要 d[i][j] != -1，说明之前已经来过了，BFS不仅仅是不走回头路，
//         更是因为第一次到达就是最短路，后面再到的肯定更远，没必要更新。
int d[N][N];   

// 【3. 手写队列 q】
// 为什么要开 N*N 这么大？因为极端情况迷宫全是路，所有点都会进队列。
// PII 是 pair<int, int>，存的是点的坐标 {x, y}。
PII q[N * N];  

int bfs()
{
    // 【4. 队列指针】
    // hh (head): 队头指针。我们要处理任务时，从 q[hh] 拿。
    // tt (tail): 队尾指针。我们要添加新任务时，放到 q[tt]。
    // 初始状态：队列里只有起点，所以 hh = 0, tt = 0。
    int hh = 0, tt = 0;
    q[0] = {0, 0};  // 把起点 {0,0} 扔进队尾

    // 初始化距离表：全部填 -1，代表"未探索区域"
    memset(d, -1, sizeof d); 
    d[0][0] = 0;             // 起点到自己的距离是 0

    // 【5. 方向向量 (Direction Vectors)】
    // 这是在二维矩阵中移动的"神器"。
    // 也就是上下左右四个方向的坐标偏移量。
    // (-1, 0) -> 上 (行号减1)
    // ( 0, 1) -> 右 (列号加1)
    // ( 1, 0) -> 下 (行号加1)
    // ( 0,-1) -> 左 (列号减1)
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    // 【BFS主循环】
    // 只要队列不空 (hh <= tt)，就一直干活
    // 大部分情况其实hh = tt 只是最后终止条件到终点无路可走了，自然就没法赋值，tt就停在最后一个有效元素上了。
    // 只是取值和赋值的顺序不同
    // auto t = q[hh ++]; 先取值后++
    // q[ ++ tt] = {x, y};  先++后赋值
    while (hh <= tt)
    {
        // 1. 取出队头：获取当前正在处理的点 t
        auto t = q[hh ++ ];

        // 2. 尝试向 4 个方向扩散
        for (int i = 0; i < 4; i ++ )
        {
            // 计算新点的坐标 (x, y)
            int x = t.first + dx[i];// t.first 是当前点的 x 坐标
            int y = t.second + dy[i];// t.second 是当前点的 y 坐标

            // 【核心判断逻辑】
            // 只有满足所有条件，才能走过去：
            // (1) x, y 不越界 (在 0~n-1 和 0~m-1 范围内)
            // (2) g[x][y] == 0 (是平地，不是墙)
            // (3) d[x][y] == -1 (是处女地，之前没人来过)
            if (x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == -1)
            {
                // 更新距离：新点的距离 = 旧点的距离 + 1
                d[x][y] = d[t.first][t.second] + 1; 
                
                // 入队：新点变成了新的“波峰”，加入队尾等待处理
                q[ ++ tt] = {x, y};                 
            }
        }
    }

    // BFS 结束时，整个图能走的点都走过了。
    // 直接查终点 (n-1, m-1) 的距离记录。
    return d[n - 1][m - 1];
}

int main()
{
    cin >> n >> m;

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            cin >> g[i][j];

    cout << bfs() << endl;

    return 0;
}

/*
 * ============================================
 *   【BFS 扩散过程深度演示】
 *   为了演示方便，我们用一个极小的 3x3 迷宫来手动跑一遍 BFS。
 * 
 *   迷宫地图 (0是路, 1是墙):
 *   (0,0) -> 0 1 0
 *   (1,0) -> 0 0 1
 *   (2,0) -> 1 0 0 <- 终点(2,2)
 *   
 *   坐标系:
 *     0 1 2 (y)
 *   0 . # .
 *   1 . . #
 *   2 # . .
 *   (x)
 * 
 *   【核心变量状态】
 *   - q[]: 队列 (存坐标)
 *   - d[][]: 距离表 (初始全为 -1)
 *   - hh: 队头, tt: 队尾
 * 
 *   --------------------------------------------
 * 
 *   1. 【初始化】
 *      - 起点 (0,0) 入队: q[0] = {(0,0)}. hh=0, tt=0.
 *      - d[0][0] = 0.
 * 
 *   2. 【Round 1】: 队列不空 (hh<=tt)
 *      - [当前队头]: q[0]=(0,0) -> 取出 t=(0,0), hh变成1.
 *      - [尝试扩散]:
 *        - 下(1,0)符合 -> d[1][0]=1 -> 入队 q[1]=(1,0), tt变成1.
 *      - [队列快照]: 
 *        q: [(0,0), (1,0), ...] 
 *             ^hh(1) ^tt(1) 
 *        (hh=1, tt=1, 队列有效元素下标范围: [1, 1], 只有(1,0))
 * 
 *   3. 【Round 2】: 队列不空
 *      - 取出队头 t = q[1] = (1,0). hh变成2.
 *      - 尝试向四周扩散:
 *        - 上 (0,0): d[0][0]是0 (已访问). 跳过. (不走回头路!)
 *        - 右 (1,1): 是路(0), d[1][1]==-1.
 *          -> d[1][1] = d[1][0] + 1 = 2.
 *          -> 入队: q[2] = {(1,1)}. tt变成2.
 *        - 下 (2,0): 是墙(1). 碰壁!
 *        - 左 (1,-1): 越界.
 *      - 本轮结束. 队列: [{(1,1)}]
 *      
 *   4. 【Round 3】: 队列不空
 *      - 取出队头 t = q[2] = (1,1). hh变成3.
 *      - 尝试向四周扩散:
 *        - 上 (0,1): 是墙.
 *        - 右 (1,2): 是墙.
 *        - 下 (2,1): 是路(0), d[2][1]==-1.
 *          -> d[2][1] = d[1][1] + 1 = 3.
 *          -> 入队: q[3] = {(2,1)}. tt变成3.
 *        - 左 (1,0): 已访问.
 *      - 本轮结束. 队列: [{(2,1)}]
 * 
 *   5. 【Round 4】: 队列不空
 *      - 取出队头 t = q[3] = (2,1). hh变成4.
 *      - 尝试扩散:
 *        - 上 (1,1): 已访问.
 *        - 右 (2,2): 是路(0), d[2][2]==-1. 
 *          -> 【发现终点!】
 *          -> d[2][2] = d[2][1] + 1 = 4.
 *          -> 入队: q[4] = {(2,2)}. tt变成4.
 *        - 下 (3,1): 越界.
 *        - 左 (2,0): 是墙.
 *      - 本轮结束. 队列: [{(2,2)}]
 * 
 *   6. 【Round 5】: 队列不空
 *      - [当前队头]: q[4]=(2,2) -> 取出 t=(2,2), hh变成5.
 *      - [尝试扩散]: 无路可走.
 *      - [队列快照]:
 *        q: [..., (2,2), ...]
 *                         ^hh(5) ^tt(4)
 *        (hh > tt, 队列空了!)
 *
 *   7. 【结束】
 *      - 循环条件 while(hh <= tt) 不满足. 退出.
 * 
 *   【关于路径输出】
 *   注意：本代码只求"最短距离"(一个数字)。
 *   因为 q[] 只是一个待办事项列表，处理完一个丢一个 (hh++)，
 *   它并不保存"我是从谁走过来的"这种亲缘关系。
 *   如果要输出 "(0,0)->(1,0)->..." 这样的完整路径，
 *   需要额外开一个数组 prev[x][y] 来记录每个点的"前驱节点" (即谁把我放进队列的)。
 * 
 *   【附：输入样例的完整运行结果】
 *   输入:
 *   5 5
 *   0 1 0 0 0
 *   0 1 0 1 0
 *   0 0 0 0 0
 *   0 1 1 1 0
 *   0 0 0 1 0
 *
 *   输出:
 *   8
 *   
 *   (路径示意: (0,0)->(1,0)->(2,0)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(4,4))
 *   (共移动8步)
 * 
 *   【总结】
 *   BFS 就像倒水。水流到哪儿，哪儿就被标记“湿了”(d!=-1)。
 *   因为水流速度一样，所以最先湿到的终点，一定是最短路径。
 * ============================================
 */
