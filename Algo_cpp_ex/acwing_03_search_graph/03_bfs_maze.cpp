/*
 * ============================================
 *   BFS (广度优先搜索) - 走迷宫
 *   题目来源：AcWing 844. 走迷宫
 *   
 *   【题目描述】
 *   给定一个 n × m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1。
 *   0 表示可以走的路，1 表示不可通过的墙壁。
 *   最初，有一个人位于左上角 (1, 1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。
 *   请问，该人从左上角移动至右下角 (n, m) 处，至少需要移动多少次。
 *   数据保证 (1, 1) 处和 (n, m) 处的数字为 0，且一定至少存在一条通路。
 *   
 *   【样例输入】
 *   5 5
 *   0 1 0 0 0
 *   0 1 0 1 0
 *   0 0 0 0 0
 *   0 1 1 1 0
 *   0 0 0 1 0
 *   
 *   【样例输出】
 *   8
 * ============================================
 *   核心思想：水波纹扩散 (Wave Propagation) + 最短路
 * ============================================
 * 
 * 【物理模型：病毒传播 / 水波纹】
 *   假设起点 (0, 0) 有一滴墨水滴入水中。
 *   墨水会向四周扩散：
 *   第 1 秒：扩散到 (0, 1), (1, 0)
 *   第 2 秒：扩散到 (0, 2), (1, 1), (2, 0) ...
 *   
 *   BFS 的本质就是层序遍历。由于墨水是匀速扩散的（每步代价都是1），
 *   所以墨水第一次到达某个点的时间，就是从起点到该点的最短时间。
 *   因此，BFS 天生就能求边权为 1 的图的最短路。
 * 
 * 【核心数据结构】
 *   1. q[N * N]: 队列 (Queue)。
 *      物理意义：当前正在扩散的波锋（边界线）。
 *      hh: 队头 (波锋的内圈)，tt: 队尾 (波锋的外圈)。
 * 
 *   2. d[N][N]: 距离数组 (Distance)。
 *      物理意义：每个点被墨水染色的时间。
 *      初始值为 -1，表示未被染色。
 * 
 *   3. dx[4], dy[4]: 方向向量。
 *      物理意义：墨水只能向 上下左右 四个方向流。
 */

#include <iostream>
#include <algorithm>
#include <cstring>  // memset

using namespace std;

typedef pair<int, int> PII;

const int N = 110;

int n, m;
int g[N][N];   // 地图：0表示空地，1表示墙壁
int d[N][N];   // 距离数组：存储每个点到起点的最短距离
PII q[N * N];  // 队列：存储点坐标 (手动模拟队列比 STL queue 快)

int bfs()
{
    int hh = 0, tt = 0;
    q[0] = {0, 0};  // 起点入队

    memset(d, -1, sizeof d); // 初始化所有点的距离为 -1 (未访问)
    d[0][0] = 0;             // 起点距离为 0

    // 方向向量：上 (-1, 0), 右 (0, 1), 下 (1, 0), 左 (0, -1)
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    // 当队列不为空时
    while (hh <= tt)
    {
        // 取出队头元素
        auto t = q[hh ++ ];

        // 尝试向四个方向扩散
        for (int i = 0; i < 4; i ++ )
        {
            int x = t.first + dx[i];
            int y = t.second + dy[i];

            // 判断边界：
            // 1. x, y 在地图范围内
            // 2. g[x][y] == 0 (是空地，不是墙)
            // 3. d[x][y] == -1 (还没被访问过，避免走回头路)
            if (x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == -1)
            {
                d[x][y] = d[t.first][t.second] + 1; // 距离 + 1
                q[ ++ tt] = {x, y};                 // 新探索到的点入队
            }
        }
    }

    // 返回终点 (n-1, m-1) 的距离
    return d[n - 1][m - 1];
}

int main()
{
    cin >> n >> m;

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            cin >> g[i][j];

    cout << bfs() << endl;

    return 0;
}

/*
 * ============================================
 *   【BFS 扩散过程深度演示】
 *   为了演示方便，我们用一个极小的 3x3 迷宫来手动跑一遍 BFS。
 * 
 *   迷宫地图 (0是路, 1是墙):
 *   (0,0) -> 0 1 0
 *   (1,0) -> 0 0 1
 *   (2,0) -> 1 0 0 <- 终点(2,2)
 *   
 *   坐标系:
 *     0 1 2 (y)
 *   0 . # .
 *   1 . . #
 *   2 # . .
 *   (x)
 * 
 *   【核心变量状态】
 *   - q[]: 队列 (存坐标)
 *   - d[][]: 距离表 (初始全为 -1)
 *   - hh: 队头, tt: 队尾
 * 
 *   --------------------------------------------
 * 
 *   1. 【初始化】
 *      - 起点 (0,0) 入队: q[0] = {(0,0)}. hh=0, tt=0.
 *      - d[0][0] = 0.
 * 
 *   2. 【Round 1】: 队列不空 (hh<=tt)
 *      - 取出队头 t = q[0] = (0,0). hh变成1.
 *      - 尝试向四周扩散:
 *        - 上 (-1,0): 越界.
 *        - 右 (0,1): 是墙(1). 碰壁!
 *        - 下 (1,0): 是路(0), 且 d[1][0]==-1 (未访问).
 *          -> d[1][0] = d[0][0] + 1 = 1.
 *          -> 入队: q[1] = {(1,0)}. tt变成1.
 *        - 左 (0,-1): 越界.
 *      - 本轮结束. 队列: [{(1,0)}]
 * 
 *   3. 【Round 2】: 队列不空
 *      - 取出队头 t = q[1] = (1,0). hh变成2.
 *      - 尝试向四周扩散:
 *        - 上 (0,0): d[0][0]是0 (已访问). 跳过. (不走回头路!)
 *        - 右 (1,1): 是路(0), d[1][1]==-1.
 *          -> d[1][1] = d[1][0] + 1 = 2.
 *          -> 入队: q[2] = {(1,1)}. tt变成2.
 *        - 下 (2,0): 是墙(1). 碰壁!
 *        - 左 (1,-1): 越界.
 *      - 本轮结束. 队列: [{(1,1)}]
 *      
 *   4. 【Round 3】: 队列不空
 *      - 取出队头 t = q[2] = (1,1). hh变成3.
 *      - 尝试向四周扩散:
 *        - 上 (0,1): 是墙.
 *        - 右 (1,2): 是墙.
 *        - 下 (2,1): 是路(0), d[2][1]==-1.
 *          -> d[2][1] = d[1][1] + 1 = 3.
 *          -> 入队: q[3] = {(2,1)}. tt变成3.
 *        - 左 (1,0): 已访问.
 *      - 本轮结束. 队列: [{(2,1)}]
 * 
 *   5. 【Round 4】: 队列不空
 *      - 取出队头 t = q[3] = (2,1). hh变成4.
 *      - 尝试扩散:
 *        - 上 (1,1): 已访问.
 *        - 右 (2,2): 是路(0), d[2][2]==-1. 
 *          -> 【发现终点!】
 *          -> d[2][2] = d[2][1] + 1 = 4.
 *          -> 入队: q[4] = {(2,2)}. tt变成4.
 *        - ... (其他方向略)
 * 
 *   6. 【后续】
 *      - 其实 BFS 还会继续把队列里的点跑完，但如果是为了求最短路，
 *        只要 d[n-1][m-1] 被更新了，理论上就可以停了 (虽然标准模板是跑完)。
 *      - 最终输出 d[2][2] = 4.
 * 
 *   【总结】
 *   BFS 就像倒水。水流到哪儿，哪儿就被标记“湿了”(d!=-1)。
 *   因为水流速度一样，所以最先湿到的终点，一定是最短路径。
 * ============================================
 */
