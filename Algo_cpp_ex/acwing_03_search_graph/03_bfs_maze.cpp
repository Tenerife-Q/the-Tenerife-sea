/*
 * ============================================
 *   BFS (广度优先搜索) - 走迷宫
 *   核心思想：水波纹扩散 (Wave Propagation) + 最短路
 * ============================================
 * 
 * 【物理模型：病毒传播 / 水波纹】
 *   假设起点 (0, 0) 有一滴墨水滴入水中。
 *   墨水会向四周扩散：
 *   第 1 秒：扩散到 (0, 1), (1, 0)
 *   第 2 秒：扩散到 (0, 2), (1, 1), (2, 0) ...
 *   
 *   BFS 的本质就是层序遍历。由于墨水是匀速扩散的（每步代价都是1），
 *   所以墨水第一次到达某个点的时间，就是从起点到该点的最短时间。
 *   因此，BFS 天生就能求边权为 1 的图的最短路。
 * 
 * 【核心数据结构】
 *   1. q[N * N]: 队列 (Queue)。
 *      物理意义：当前正在扩散的波锋（边界线）。
 *      hh: 队头 (波锋的内圈)，tt: 队尾 (波锋的外圈)。
 * 
 *   2. d[N][N]: 距离数组 (Distance)。
 *      物理意义：每个点被墨水染色的时间。
 *      初始值为 -1，表示未被染色。
 * 
 *   3. dx[4], dy[4]: 方向向量。
 *      物理意义：墨水只能向 上下左右 四个方向流。
 */

#include <iostream>
#include <algorithm>
#include <cstring>  // memset

using namespace std;

typedef pair<int, int> PII;

const int N = 110;

int n, m;
int g[N][N];   // 地图：0表示空地，1表示墙壁
int d[N][N];   // 距离数组：存储每个点到起点的最短距离
PII q[N * N];  // 队列：存储点坐标 (手动模拟队列比 STL queue 快)

int bfs()
{
    int hh = 0, tt = 0;
    q[0] = {0, 0};  // 起点入队

    memset(d, -1, sizeof d); // 初始化所有点的距离为 -1 (未访问)
    d[0][0] = 0;             // 起点距离为 0

    // 方向向量：上 (-1, 0), 右 (0, 1), 下 (1, 0), 左 (0, -1)
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    // 当队列不为空时
    while (hh <= tt)
    {
        // 取出队头元素
        auto t = q[hh ++ ];

        // 尝试向四个方向扩散
        for (int i = 0; i < 4; i ++ )
        {
            int x = t.first + dx[i];
            int y = t.second + dy[i];

            // 判断边界：
            // 1. x, y 在地图范围内
            // 2. g[x][y] == 0 (是空地，不是墙)
            // 3. d[x][y] == -1 (还没被访问过，避免走回头路)
            if (x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == -1)
            {
                d[x][y] = d[t.first][t.second] + 1; // 距离 + 1
                q[ ++ tt] = {x, y};                 // 新探索到的点入队
            }
        }
    }

    // 返回终点 (n-1, m-1) 的距离
    return d[n - 1][m - 1];
}

int main()
{
    cin >> n >> m;

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            cin >> g[i][j];

    cout << bfs() << endl;

    return 0;
}
