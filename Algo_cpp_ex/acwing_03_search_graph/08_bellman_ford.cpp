/*
 * ============================================
 *   Bellman-Ford 算法 - 处理负权边 & 限制边数
 *   时间复杂度：O(k * M)  (如果无限制k则为N*M)
 *   
 *   【核心区别对比：Dijkstra vs Bellman-Ford】
 *   
 *   1. 【处理负权边】
 *      - Dijkstra [NO]: 贪心策略假设“边权非负，路越走越远”。遇到
 *        负权边(能让路变短)，贪心就失效了。
 *      - Bellman-Ford [YES]: 暴力把所有边都试一遍，不怕负数。哪怕减
 *        成了负无穷也能算出来。
 * 
 *   2. 【处理带限制的最短路 (k条边)】
 *      - Dijkstra [NO]: 它按照距离从小到大扩展，根本不管用了几条边。
 *      - Bellman-Ford [YES]: 它按层级(次数)由外向内扩展，第 k 轮循
 *        环严格对应“经过 k 条边”。
 * 
 *   3. 【效率】
 *      - Dijkstra [优]: O(M log N)，极其高效。
 *      - Bellman-Ford [慢]: O(N * M)，非常暴力，容易超时。
 *        (如果没有负权边和步数限制，首选 Dijkstra)
 * 
 * 
 *  输入输出示例：
 *  3 3 2
    1 2 2
    1 3 5
    2 3 1
    输出：3
 *    解释：从1到3，最多经过2条边。1->3是5，1->2->3是2+1=3。答案是3。
 * ============================================
 */

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 510, M = 10010;

int n, m, k; // n: 点数, m: 边数, k: 限制最多经过 k 条边
int dist[N];   // [路程表] 记录“目前发现的”从起点到各个点的最短距离
int backup[N]; // [备份表] 上一轮的最短距离 (防止串联更新)

// 结构体数组：不需要复杂的邻接表，只需要把所有边一条条列出来
struct Edge
{
    int a, b, w; // a -> b 权重为 w
} edges[M]; // 数组 edges[j] 存储第 j 条边

int bellman_ford()
{
    // [初始化]
    // 刚开始，除了自己(起点1)是0，去哪都是无穷远
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // [外层循环 k 次]
    // 意义：第 i 次循环，表示"只允许经过不超过 i 条边"到达各点的最短距离。
    // 如果 k=1，其实就是求所有直达的路径。
    for (int i = 0; i < k; i ++ )
    {
        /* 
         * ============================================
         * 【关于备份数组 backup 的深度解析】
         * Q: 为什么需要备份？是算法本身的妥协吗？
         * A:是的！这是为了严格遵守 "k条边限制" 而必须做的妥协。
         * 
         * 【场景模拟】
         * 假设图是：1->2 (距离1), 2->3 (距离1)。
         * 现在的限制是：k=1 (只能走1条边)。
         * 
         * [不备份的情况 - 发生串联(串味了)]
         * 1. 我们不用 backup，直接用 dist 数组。
         * 2. 遍历到第一条边 1->2：
         *    dist[2] 马上被更新为 dist[1]+1 = 0+1 = 1。
         * 3. 同一轮循环，紧接着遍历第二条边 2->3：
         *    dist[3] = min(dist[3], dist[2] + 1)。
         *    注意！这里的 dist[2] 已经是新的 1 了！
         *    于是 dist[3] 变成了 1+1 = 2。
         * 
         * -> 结果：我们在第1轮循环里，实际上走了两步 (1->2->3)，算出了距离2。
         * -> 错误：题目要求只能走1条边，dist[3] 应该是正无穷才对！
         * 
         * [备份的情况 - 只有上一轮的旧数据]
         * 1. 每一轮开始前，把 dist 抄到 backup 里。
         * 2. 遍历 1->2：backup[1]是0 -> 更新 dist[2]=1。
         * 3. 遍历 2->3：backup[2]是正无穷(因为是以i-1轮的状态为准) -> dist[3] 无法更新。
         * -> 正确：dist[3] 保持无穷大。
         * ============================================
         */
        memcpy(backup, dist, sizeof dist);

        // [内层循环：遍历所有边]
        // 不管三七二十一，把 m 条边全部拿出来试一遍
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a; // 边的起点
            int b = edges[j].b; // 边的终点
            int w = edges[j].w; // 边的权重 (可以是负数!)

            // [松弛操作]
            // 尝试用经过 a点 的旧路程 (backup[a]) 加上这条边 w，看看能不能让 b点 更近
            dist[b] = min(dist[b], backup[a] + w);
        }
    }

    // [返回值判定]
    // 为什么不用 == 0x3f3f3f3f？
    // 因为如果有负权边存在，dist[n] 可能会被一个无穷大的数更新成 "无穷大 - 2"。
    // 虽然比 0x3f3f3f3f 小了一点点，但它依然表示"不可达" (毕竟无穷大减去2依然很大)。
    // 所以只要它还是很大 (> 一半的无穷大)，我们就认为它不可达。
    if (dist[n] > 0x3f3f3f3f / 2) return -0x3f3f3f3f; // 返回一个特殊标记
    return dist[n];
}

/*
struct Edge{
    int a, b, w;
} edges[M];

int bellman_ford(){
    memset(dist, 0x3ff, sizeof dist);
    dist[1] = 0;
    for(int i = 0; i < k; i ++ ) {
        memset(backup, 0x3ff, sizeof dist);
        for(int j = 0; j < m; j ++ ) {
            int a = edges[j].a;
            int b = edges[j].b;
            int w = edges[j].w;
            dist[b] = min(dist[b], backup[a] + w);
        }
    }
    return dist[n] > 0x3f3f3f3f / 2 ? -0x3f3f3f3f : dist[n];
}
*/


int main()
{
    scanf("%d%d%d", &n, &m, &k);

    for (int i = 0; i < m; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        edges[i] = {a, b, c};
    }

    int t = bellman_ford();

    if (t == -0x3f3f3f3f) puts("impossible"); // 题目要求这种情况下输出 impossible
    else printf("%d\n", t);

    return 0;
}

/*
 * =========================================================================
 * 【深度解析：为什么 Bellman-Ford 必须这么做？(k步限制 vs 无限制)】
 * 
 * 1. 题目类型决定算法选择：
 *    - 如果题目问："求最短路" (无步数限制, 且边权非负) -> 首选 Dijkstra。
 *    - 如果题目问："求最多经过 k 条边的最短路" -> 必须用 Bellman-Ford。
 *    - 如果题目问："图中有负权边，求最短路" -> 只能用 Bellman-Ford (或其优化版 SPFA)。
 * 
 * 2. 为什么要【备份数组 (backup)】？
 *    案例演示：
 *    假设图：1 -> 2 (距离1), 2 -> 3 (距离1)。
 *    我们现在处于第 1 轮循环 (k=1)，也就是"只允许走 1 条边"。
 * 
 *    [方式 A: 不备份 (错误)]
 *    - 遍历边 1->2: dist[2] 变为了 1。 (正常，走了1步)
 *    - 遍历边 2->3: dist[3] 用新的 dist[2] 更新 -> 1+1=2。
 *      (错误！dist[3] 实际上利用了 1->2 和 2->3 两条边，走了 2 步！)
 *      (在 k=1 的限制下，dist[3] 应该是正无穷才对)
 * 
 *    [方式 B: 备份 (正确)]
 *    - 先把 dist 抄一份给 backup。 (backup[1]=0, backup[2]=∞, ...)
 *    - 遍历边 1->2: 用 backup[1] 更新 dist[2] -> 变为了 1。
 *    - 遍历边 2->3: 用 backup[2] 更新 dist[3] -> backup[2]是∞ -> dist[3] 没变。
 *      (正确！dist[3] 还是无穷大，符合"只走1步"的事实)
 * 
 * =========================================================================
 * 【横向对比：Bellman-Ford vs Dijkstra】
 * 
 * | 特征 | Dijkstra (绅士) | Bellman-Ford (暴力狂) |
 * | :--- | :--- | :--- |
 * | **核心逻辑** | **贪心** (谁近选谁) | **暴力迭代** (不管三七二十一全松弛) |
 * | **适用范围** | 正权图 (绝配) | 负权图 / k步限制图 (Dijkstra做不到) |
 * | **复杂度**   | O(M log N) (快) | O(k * M) (慢，k最大可以是N) |
 * | **判断负环** | 不能 | 能 (如果在第 N 轮还能变短，说明有负环) |
 * | **步数限制** | 不能处理 | 天然支持 (由外层循环 k 控制) |
 * =========================================================================
 */
