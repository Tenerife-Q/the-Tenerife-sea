/*
 * ============================================
 *   DFS - N皇后问题 (N-Queens)
 *   核心思想：剪枝 (Pruning) + 二维冲突检测
 * ============================================
 * 
 * 【物理模型：雷达监控】
 *   整个棋盘被四个方向的雷达监控着。
 *   皇后放在 (r, c) 时，会立即触发以下警报：
 *   1. 行雷达：第 r 行被占用了。（DFS按行枚举，这个不用写显式判断，因为每行只放一个就走）
 *   2. 列雷达：第 c 列被占用了。 -> col[c] = true
 *   3. 主对角线雷达：左上到右下的斜线。 -> dg[u + i] = true
 *   4. 副对角线雷达：右上到左下的斜线。 -> udg[u - i + n] = true
 * 
 * 【神之一手：对角线映射技巧】
 *   如何把二维的斜线映射成一维数组下标？
 *   - 主对角线 (y = x + b -> b = y - x):  idx = u - i + n (加上 n 防止下标变负)
 *   - 副对角线 (y = -x + b -> b = y + x): idx = u + i
 * 
 * 【搜索策略】
 *   不用管怎么放，只要确定：
 *   “当前第 u 行，把皇后放到第 i 列，会不会被前面的皇后攻击到？”
 *   如果不被攻击，就放下去，然后立刻去下一行 (u + 1)。
 *   如果每一列都不能放，说明上一行放错了，回溯！
 */

#include <iostream>

using namespace std;

const int N = 20; // 稍大一点，防止越界

int n;
char g[N][N]; // 物理棋盘，存储 '.' 或 'Q'
bool col[N], dg[N], udg[N]; // 列、对角线、副对角线 是否被占用

// u: 当前枚举到了第几行
void dfs(int u)
{
    // 【边界条件】
    // 如果搜到了第 n 行 (0 ~ n-1 都填好了)，说明找到一组解
    if (u == n)
    {
        for (int i = 0; i < n; i ++ ) puts(g[i]);
        puts(""); // 此时输出整个棋盘
        return;
    }

    // 【枚举过程】
    // 在第 u 行，尝试把皇后放在第 i 列 (0 ~ n-1)
    for (int i = 0; i < n; i ++ )
    {
        // 核心判断：第 i 列、正对角线 (u+i)、副对角线 (n-u+i) 都没被雷达扫到
        // 注意：udg下标通常用 n - u + i 或 u - i + n 防止负数，只要保证一一对应且不越界即可
        // 这里用 u + i 对应副对角线， n - u + i 对应主对角线
        if (!col[i] && !dg[u + i] && !udg[n - u + i])
        {
            g[u][i] = 'Q';      // 1. 放皇后
            col[i] = dg[u + i] = udg[n - u + i] = true; // 2. 开启雷达报警
            
            dfs(u + 1);         // 3. 去下一行

            // 【回溯恢复】
            // 撤销刚才的操作，必须完全逆向
            col[i] = dg[u + i] = udg[n - u + i] = false; // 4. 关闭雷达
            g[u][i] = '.';      // 5. 拿走皇后
        }
    }
}

int main()
{
    cin >> n;

    // 初始化棋盘全为 '.'
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            g[i][j] = '.';

    // 从第 0 行开始搜索
    dfs(0);

    return 0;
}
