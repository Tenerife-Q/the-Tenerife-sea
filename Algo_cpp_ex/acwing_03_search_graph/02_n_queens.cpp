/*
 * ============================================
 *   DFS - N皇后问题 (N-Queens)
 *   题目来源：AcWing 843. n-皇后问题
 *   
 *   【题目描述】
 *   n-皇后问题是指将 n 个皇后放在 n × n 的国际象棋棋盘上，使得皇后不能相互攻击到，即：
 *   1. 任意两个皇后都不能处于同一行。
 *   2. 任意两个皇后都不能处于同一列。
 *   3. 任意两个皇后都不能处于同一条斜线上（包括主对角线和副对角线）。
 *   
 *   现在给定整数 n，请你输出所有的满足条件的棋盘放置方案。
 *   
 *   【输入格式】
 *   一个整数 n (1 ≤ n ≤ 9)。
 *   
 *   【输出格式】
 *   每个方案占 n 行，每行 n 个字符。
 *   '.' 表示空地，'Q' 表示皇后。
 *   行末不能有多余空格。
 *   每个方案输出完成后，输出一个空行。
 *   
 *   【样例输入】
 *   4
 *   
 *   【样例输出】
 *   .Q..
 *   ...Q
 *   Q...
 *   ..Q.
 *   
 *   ..Q.
 *   Q...
 *   ...Q
 *   .Q..
 * ============================================
 * 
 *   核心思想：剪枝 (Pruning) + 二维冲突检测
 * ============================================
 * 
 * 【物理模型：雷达监控】
 *   整个棋盘被四个方向的雷达监控着。
 *   皇后放在 (r, c) 时，会立即触发以下警报：
 *   1. 行雷达：第 r 行被占用了。（DFS按行枚举，这个不用写显式判断，因为每行只放一个就走）
 *   2. 列雷达：第 c 列被占用了。 -> col[c] = true
 *   3. 主对角线雷达：左上到右下的斜线。 -> dg[u + i] = true
 *   4. 副对角线雷达：右上到左下的斜线。 -> udg[u - i + n] = true
 * 
 * 【神之一手：对角线映射技巧】
 *   如何把二维的斜线映射成一维数组下标？
 *   - 主对角线 (y = x + b -> b = y - x):  idx = u - i + n (加上 n 防止下标变负)
 *   - 副对角线 (y = -x + b -> b = y + x): idx = u + i
 * 
 * 【搜索策略】
 *   不用管怎么放，只要确定：
 *   “当前第 u 行，把皇后放到第 i 列，会不会被前面的皇后攻击到？”
 *   如果不被攻击，就放下去，然后立刻去下一行 (u + 1)。
 *   如果每一列都不能放，说明上一行放错了，回溯！
 */

#include <iostream>

using namespace std;

const int N = 20; // 稍大一点，防止越界

int n;
char g[N][N]; // 物理棋盘，存储 '.' 或 'Q'
bool col[N], dg[N], udg[N]; // 列、对角线、副对角线 是否被占用

// u: 当前枚举到了第几行
void dfs(int u)
{
    // 【边界条件】
    // 如果搜到了第 n 行 (0 ~ n-1 都填好了)，说明找到一组解
    if (u == n)
    {
        for (int i = 0; i < n; i ++ ) puts(g[i]);
        puts(""); // 此时输出整个棋盘
        return;
    }

    // 【枚举过程】
    // 在第 u 行，尝试把皇后放在第 i 列 (0 ~ n-1)
    for (int i = 0; i < n; i ++ )
    {
        // 核心判断：第 i 列、正对角线 (u+i)、副对角线 (n-u+i) 都没被雷达扫到
        // 注意：udg下标通常用 n - u + i 或 u - i + n 防止负数，只要保证一一对应且不越界即可
        // 这里用 u + i 对应副对角线， n - u + i 对应主对角线
        if (!col[i] && !dg[u + i] && !udg[n - u + i])
        {
            g[u][i] = 'Q';      // 1. 放皇后
            col[i] = dg[u + i] = udg[n - u + i] = true; // 2. 开启雷达报警
            
            dfs(u + 1);         // 3. 去下一行

            // 【回溯恢复】
            // 撤销刚才的操作，必须完全逆向
            col[i] = dg[u + i] = udg[n - u + i] = false; // 4. 关闭雷达
            g[u][i] = '.';      // 5. 拿走皇后
        }
    }
}

int main()
{
    cin >> n;

    // 初始化棋盘全为 '.'
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            g[i][j] = '.';

    // 从第 0 行开始搜索
    dfs(0);

    return 0;
}

/*
 * ============================================
 *   【n=4 皇后的完整执行流深度演示】
 *   为了不让篇幅爆炸，我们只追踪从“第一行放第一列”开始的那个分支，直到找到第一个解。
 *   这是一次惊心动魄的“试探-碰壁-回溯”之旅。
 * 
 *   【符号说明】
 *   - u: 当前正在尝试填第几行 (行号 0 ~ n-1)
 *   - i: 当前正在尝试放在第几列 (列号 0 ~ n-1)
 *   - col: 列冲突   | dg: 正对角线冲突 | udg: 反对角线冲突
 *   - Q: 放皇后     | .: 空地
 * 
 *   --------------------------------------------
 * 
 *   1. 【dfs(0) 开始】: u=0 (第0行)
 *      - i=0. 检查雷达... 安全!
 *      - [ACTION]: 在 (0,0) 放 Q. 开启雷达: col[0], dg[0], udg[4].
 *      - 棋盘:
 *        Q . . .
 *        . . . .
 *        . . . .
 *        . . . .
 *      -> 呼叫 dfs(1)
 * 
 *      2. 【dfs(1) 开始】: u=1 (第1行)
 *         - i=0. 检查雷达... 滴滴! col[0] 有警报 (冲撞了(0,0)). 跳过.
 *         - i=1. 检查雷达... 滴滴! dg[1+1=2] 没换算对? 
 *            (注意: dg下标是 u+i=2, udg下标是 n-u+i=4-1+1=4. udg[4]有警报!). 
 *            (即 (1,1) 和 (0,0) 在同一条副对角线上). 跳过.
 *         - i=2. 检查雷达... 安全!
 *         - [ACTION]: 在 (1,2) 放 Q. 开启雷达: col[2], dg[3], udg[3].
 *         - 棋盘:
 *           Q . . .
 *           . . Q .
 *           . . . .
 *           . . . .
 *         -> 呼叫 dfs(2)
 * 
 *         3. 【dfs(2) 开始】: u=2 (第2行)
 *            - i=0. col[0] 冲突.
 *            - i=1. dg[1] 安全? udg[4-2+1=3] 冲突 (撞(1,2)).
 *            - i=2. col[2] 冲突.
 *            - i=3. dg[2+3=5] 安全. udg[4-2+3=5] 安全. col[3] 安全.
 *            - i=3. 安全! 
 *            - ? 等等，仔细检查 i=3:
 *               dg[2+3=5], udg[4-2+3=5], col[3]. 
 *               等等，(1,2)开启的是 dg[1+2=3], udg[4-1+2=5].
 *               啊! (2,3) 的 udg 是 5, (1,2) 的 udg 也是 5. 撞了!
 *               (1,2) 在副对角线 y=x+1 -> b=1.
 *               (2,3) 在副对角线 y=x+1 -> b=1.
 *               这里模拟需要非常精确:
 *                 (0,0): dg[0], udg[4]
 *                 (1,2): dg[3], udg[5] 
 *            - 重新检查 dfs(2) 的 i=3:
 *              col[3] OK. dg[5] OK. udg[4-2+3=5] -> 撞了(1,2)!
 *              所以 i=3 也不行!
 *            
 *            - i=0~3 全军覆没! 无法放置皇后。
 *            - return 回到 dfs(1) (回溯!)
 * 
 *         (回到 dfs(1))
 *         - 刚才在 (1,2) 放 Q 导致死胡同。
 *         - [BACKTRACK]: 撤销 (1,2). Q变回.. col[2], dg[3], udg[5] 解除警报.
 *         - 尝试 i=3. 安全!
 *         - [ACTION]: 在 (1,3) 放 Q.
 *         - 棋盘:
 *           Q . . .
 *           . . . Q
 *           . . . .
 *           . . . .
 *         -> 呼叫 dfs(2)
 * 
 *         3. 【dfs(2) 开始】: u=2
 *            - i=0. col[0] 冲突.
 *            - i=1. 安全! (0,0)占col[0],dg[0],udg[4]. (1,3)占col[3],dg[4],udg[6].
 *               (2,1): col[1] ok, dg[3] ok, udg[4-2+1=3] ok.
 *            - [ACTION]: 在 (2,1) 放 Q.
 *            - 棋盘:
 *              Q . . .
 *              . . . Q
 *              . Q . .
 *              . . . .
 *            -> 呼叫 dfs(3)
 * 
 *            4. 【dfs(3) 开始】: u=3
 *               - i=0. col[0] 冲突.
 *               - i=1. col[1] 冲突.
 *               - i=2. 安全?!
 *                  (0,0)->udg[4], (1,3)->udg[6], (2,1)->udg[3].
 *                  (3,2): udg[4-3+2=3] -> 撞了(2,1)! 跳过.
 *               - i=3. col[3] 冲突.
 *               - 全军覆没! 
 *               - return 回到 dfs(2)
 * 
 *            (回到 dfs(2))
 *            - (2,1) 不行. 撤销.
 *            - i=2,3 都有冲突.
 *            - return 回到 dfs(1)
 * 
 *         (回到 dfs(1))
 *         - (1,3) 也不行. 撤销.
 *         - i=0~3 都试过了.
 *         - return 回到 dfs(0)
 * 
 *      (回到 dfs(0))
 *      - 刚才 (0,0) 的路走不通! 
 *      - [BACKTRACK]: 撤销 (0,0). Q变回..
 *      - 尝试 i=1.
 *      - [ACTION]: 在 (0,1) 放 Q.
 *      - ... (这将开启 2 4 1 3 的正确解分支) ...
 * 
 * ============================================
 */
