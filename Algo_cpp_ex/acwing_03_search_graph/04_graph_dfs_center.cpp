/*
 * ============================================
 *   DFS应用 - 树的重心 (Tree Centroid)
 *   核心思想：连通块大小计算 + 全局最小值更新
 * ============================================
 * 
 * 【由搜索迈向图论的第一步：邻接表 (Adjacency List)】
 * 
 *   您的理解完全正确！核心就这三句话：
 *   1. h[u]   (Head): 存的是起点 u 挂的 "第一条边的索引(idx)"。
 *   2. e[idx] (Edge): 存的是索引为 idx 的那条边指向的 "终点节点编号"。
 *   3. ne[idx](Next): 存的是索引为 idx 的那条边的 "下一条边的索引"。
 * 
 *   【内存结构图解：两步建立边 1->2 和 1->5】
 * 
 *   场景：初始化 idx=0, h[]全为-1
 * 
 *   [Step 1] add(1, 2)  --> idx=0 (赋予这条边编号0)
 *   -------------------------------------------------------
 *   内存动作：
 *   1. e[0] = 2;       (0号边通向2)
 *   2. ne[0] = h[1];   (0号边下一条是 -1, 此时 h[1] 还是空的)
 *   3. h[1] = 0;       (起点 1 的头变成了 0号边)
 *   4. idx++;          (idx变成1)
 * 
 *   逻辑链表： Point(1) -> Edge(0, to:2) -> NULL
 *   -------------------------------------------------------
 * 
 *   [Step 2] add(1, 5)  --> idx=1 (赋予这条边编号1)
 *   此步骤关键：新边插在最前面！(头插法)
 *   -------------------------------------------------------
 *   内存动作：
 *   1. e[1] = 5;       (1号边通向5)
 *   2. ne[1] = h[1];   (1号边下一条是 0号边! 因为刚才 h[1]=0)
 *   3. h[1] = 1;       (起点 1 的头变成了 1号边)
 *   4. idx++;          (idx变成2)
 * 
 *   逻辑链表： Point(1) -> Edge(1, to:5) -> Edge(0, to:2) -> NULL
 *   -------------------------------------------------------
 * 
 *   [最终数组快照]
 *   
 *   下标(idx) |  e[idx] (终点) | ne[idx] (下一边) | 备注
 *   ----------|----------------|------------------|----------------
 *       0     |       2        |       -1         | 第一条边 (1->2)
 *       1     |       5        |        0         | 第二条边 (1->5)
 *   
 *   h[1] = 1  (起点1首先找到 idx=1 的边)
 * 
 *   [遍历过程] for (int i = h[1]; i != -1; i = ne[i])
 *   1. i = h[1] = 1.  访问 e[1] (点5).  准备跳到 ne[1] (是0).
 *   2. i = 0.         访问 e[0] (点2).  准备跳到 ne[0] (是-1).
 *   3. i = -1.        结束.
 * 
 * ============================================
 * 
 * 【什么是“重心”？】
 *   物理直觉：如果你拎起树上的某个节点，整棵树会垂下来，变成一串葡萄。
 *   - 如果你拎的是叶子节点，整棵树都坠在下面，很重（最大连通块大）。
 *   - 如果你拎的是中间的平衡点，周围分散的葡萄串都差不多大（最大连通块小）。
 *   这个让“最大那一串”尽可能小的点，就是重心。
 * 
 *   【为什么 ans 越小越好？】
 *   - res 代表：如果删掉当前点，最糟糕（最大）的那一坨连通块有多大。
 *   - ans 代表：所有方案中，那个“最糟糕的连通块”的最小值。
 *   - 比如：
 *     方案A删点1: 最大连通块是 100。
 *     方案B删点2: 最大连通块是 50。（更好，更平衡）
 *     所以我们求的是 min(所有方案的res)。
 * 
 * 【代码执行日志预演：N=4 的树】
 * 
 *   结构图：
 *       1
 *      / \
 *     2   3
 *    /
 *   4
 * 
 *   [DFS 递归流程图] - 后序遍历 (先子后父)
 * 
 *   DFS(1) 启动! (开始计算以1为根的情况)
 *   |
 *   +-- 发现子节点 2 -> 呼叫 DFS(2)
 *   |    |
 *   |    +-- 发现子节点 4 -> 呼叫 DFS(4)
 *   |    |    |
 *   |    |    +-- 4 是叶子，无子节点。
 *   |    |    +-- 汇报 sum=1 (我自己)。
 *   |    |    +-- 4 的 res = max(下方0, 上方3) = 3。
 *   |    |    +-- 更新全局 ans = min(inf, 3) = 3。
 *   |    |    +-- 返回 1 给 2。
 *   |    |
 *   |    +-- DFS(2) 收到了 4 的汇报 (s=1)。
 *   |    +-- 2 的 sum = 1(自己) + 1(来自4) = 2。
 *   |    +-- 2 的 res = max(下方1, 上方2) = 2。
 *   |        (注: 上方 = n - sum = 4 - 2 = 2，即节点1和3)
 *   |    +-- 更新全局 ans = min(3, 2) = 2。
 *   |    +-- 返回 2 给 1。
 *   |
 *   +-- DFS(1) 收到了 2 的汇报 (s=2)。
 *   |   (暂存: 1号目前的最大下属是 2人)
 *   |
 *   +-- 发现子节点 3 -> 呼叫 DFS(3)
 *   |    |
 *   |    +-- 3 是叶子。
 *   |    +-- 汇报 sum=1。
 *   |    +-- 3 的 res = max(下方0, 上方3) = 3。
 *   |    +-- 更新全局 ans = min(2, 3) = 2 (没变)。
 *   |    +-- 返回 1 给 1。
 *   |
 *   +-- DFS(1) 收到了 3 的汇报 (s=1)。
 *   +-- 1 的 sum = 1(自己) + 2(来自2) + 1(来自3) = 4。
 *   +-- 1 的 res = max(最大下属2, 上方0) = 2。
 *   +-- 更新全局 ans = min(2, 2) = 2。
 *   +-- 返回 4 (任务结束)。
 *   
 *   最终答案 ans = 2。
 */

#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 100010; // 点的个数
const int M = N * 2;  // 边的个数 (无向图，每条边存两次，所以要乘2！)

int n;
// 邻接表存储图
// h: 头指针数组 (Head)，h[u] 存储节点 u 的第一条边的 idx
// e: 边值数组 (Element)，e[idx] 存储第 idx 条边指向哪个节点
// ne: Next指针数组，ne[idx] 存储第 idx 条边的下一条边在哪里
// idx: 内存指针，当前用到第几条边了（相当于 malloc 的游标）
int h[N], e[M], ne[M], idx;
// st[u]: 记录节点 u 是否被访问过，防止走回头路 (树中防止搜回父节点)
bool st[N];

// ans: 用于记录全局答案（删除某个点后，最大连通块的最小值）
// 初始化为一个很大的数，方便后续 min 更新
int ans = N;

// 添加一条边 a -> b (头插法)
// 物理动作：把一张写着“去b”的卡片，插到 h[a] 这一摞卡片的最上面
void add(int a, int b)
{
    e[idx] = b;       // 1. 创建新边节点：准备一张新卡片，写上终点 b
    ne[idx] = h[a];   // 2. 继承旧关系：新卡片的 next 指针，指向 h[a] 之前挂的那张卡片
    h[a] = idx ++ ;   // 3. 更新头指针：把墙上 h[a] 的挂钩，指向这张新卡片 (idx)，然后 idx 自增
}

// DFS 并不是为了“搜索”什么，而是为了“统计信息”
// 返回以 u 为根的子树中点的数量
int dfs(int u)
{
    st[u] = true; // 标记当前点已访问

    // sum: 记录以 u 为根的子树的总点数（包括 u 自己，所以初值为 1）
    // res: 记录删除 u 后，剩余连通块中最大的那个连通块的大小 (局部变量，每个节点都不一样)
    int sum = 1, res = 0;

    // 遍历 u 的所有出边 (链表遍历模板)
    // 从 h[u] 开始，顺着 ne 往下找，直到 -1 结束
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i]; // j 是 u 的邻居节点

        // 如果 j 没有被访问过 (避免遍历回父节点)
        // 树是无向图，a-b 存在，b-a 也存在。防止DFS跑到儿子又跑回爹。
        if (!st[j])
        {
            // [Recursion] 递归！
            // 问儿子 j：“你那棵树总共有多少人？”
            int s = dfs(j);
            
            // 此时 s 是删掉 u 后，下方某一个分支的大小
            // 我们要找下方分支里最大的那个
            res = max(res, s);
            
            // 将子树 j 的点数加到 u 的 sum 里
            sum += s;
        }
    }

    // 此时 loop 结束，所有子节点都汇报完毕。
    // res 里存的是“下方”所有连通块的最大值。
    
    // 还要考虑“上方”的连通块。
    // 当我们把 u 删掉，整棵树会被切分。
    // 下面是若干个子树，上面是 (总点数 n - u的整个子树 sum)
    res = max(res, n - sum);

    // 更新全局答案：我们要找的是所有点中，“最大连通块”最小的那个值
    // ans 是一个全局变量，记录历史最优解
    ans = min(ans, res);

    // [Return] 向上级汇报
    // 告诉我的父节点：“以我 u 为根的这坨子树，总共有 sum 这么大”
    return sum;
}

/*

*/

void add(int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}

int dfs(int u) {
    st[u] = true;
    int sum = 1, res = 0;
    for(int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if(!st[j]) {
            int s = dfs(j);
            res = max(res, s);
            sum += s;
        }
    }
    res = max(res, n - sum);
    ans = min(ans, res);
    return sum;
}

int main()
{
    // 输入点数
    cin >> n;

    // 邻接表初始化：头指针全部为 -1
    // 这一步非常重要！否则 h[] 里是内存随机值，最后不知道链表哪里结束
    memset(h, -1, sizeof h);

    // 读入 n-1 条边 (树的性质：n个点 n-1 条边，没有环)
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b;
        cin >> a >> b;
        // 无向图，加双向边
        // 因为并不知道你是父还是我是父，存下来再说，DFS 会利用 st 数组避免回头
        add(a, b); 
        add(b, a);
    }

    // 从任意一个点开始搜都可以，通常从 1 号点开始
    // 因为是无向连通图，从任何点开始都能遍历到所有点
    dfs(1);

    cout << ans << endl;

    return 0;
}
