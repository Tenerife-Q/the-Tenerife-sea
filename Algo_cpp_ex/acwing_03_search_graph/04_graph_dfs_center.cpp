/*
 * ============================================
 *   DFS应用 - 树的重心 (Tree Centroid)
 *   核心思想：连通块大小计算 + 全局最小值更新
 * ============================================
 * 
 * 【由搜索迈向图论的第一步：邻接表】
 *   既然是图论，首先要把图存下来。
 *   在算法竞赛中，为了极致的速度，我们不用 vector<vector<int>>，也不用 struct Node*，
 *   而是用数组模拟链表 —— 邻接表 (Adjacency List)。
 *   
 *   物理结构：
 *   h[u]: 第 u 个点的链表头指针 (head of u)
 *   e[i]: 第 i 条边的终点 (element / edge target)
 *   ne[i]: 第 i 条边的下一条边指针 (next edge)
 *   idx: 内存分配指针 (index)
 * 
 * 【什么是“重心”？】
 *   物理直觉：如果你拎起树上的某个节点，整棵树会垂下来。
 *   有些节点拎起来，最长的一串葡萄特别重（连通块很大）；
 *   有些节点拎起来，所有分支都比较均匀（最大连通块最小）。
 *   那个让“最大分支重量”最小的节点，就是重心。
 * 
 *   数学定义：删除该点后，剩余各个连通块中点数的最大值最小。
 * 
 * 【DFS 的返回值设计】
 *   dfs(u) 的返回值定义为：以 u 为根的子树的大小（包含 u 自己）。
 *   这非常关键！因为如果不返回子树大小，父节点就无法知道删掉连线后下面这一坨有多大。
 */

#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 100010; // 点的个数
const int M = N * 2;  // 边的个数 (无向图，每条边存两次，所以要乘2！)

int n;
// 邻接表存储图
int h[N], e[M], ne[M], idx;
// st[u]: 记录节点 u 是否被访问过，防止走回头路 (树中防止搜回父节点)
bool st[N];

// ans: 用于记录全局答案（删除某个点后，最大连通块的最小值）
// 初始化为一个很大的数，方便后续 min 更新
int ans = N;

// 添加一条边 a -> b
void add(int a, int b)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++ ;
}

// 返回以 u 为根的子树中点的数量
int dfs(int u)
{
    st[u] = true; // 标记当前点已访问

    // sum: 记录以 u 为根的子树的总点数（包括 u 自己，所以初值为 1）
    // res: 记录删除 u 后，剩余连通块中最大的那个连通块的大小
    int sum = 1, res = 0;

    // 遍历 u 的所有出边 (链表遍历模板)
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i]; // j 是 u 的邻居节点

        // 如果 j 没有被访问过 (避免遍历回父节点)
        if (!st[j])
        {
            // 递归计算子树 j 的大小
            int s = dfs(j);
            
            // 当前子树 j 就是一个连通块，更新最大连通块大小
            res = max(res, s);
            
            // 将子树 j 的点数加到 u 的总点数中
            sum += s;
        }
    }

    // 此时，res 记录了 u 下方所有子树中最大的那一块。
    // 但别忘了，删除 u 后，还有“上面”那一块（整棵树除去 u 的子树部分）。
    // 上面那一块的大小 = 总点数 n - 以 u 为根的子树大小 sum
    res = max(res, n - sum);

    // 更新全局答案：我们要找的是所有点中，res 最小的那个
    ans = min(ans, res);

    // 返回以 u 为根的子树大小，供 u 的父节点使用
    return sum;
}

int main()
{
    // 输入点数
    cin >> n;

    // 邻接表初始化：头指针全部为 -1
    memset(h, -1, sizeof h);

    // 读入 n-1 条边 (树的性质)
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b;
        cin >> a >> b;
        // 无向图，加双向边
        add(a, b); 
        add(b, a);
    }

    // 从任意一个点开始搜都可以，通常从 1 号点开始
    dfs(1);

    cout << ans << endl;

    return 0;
}
