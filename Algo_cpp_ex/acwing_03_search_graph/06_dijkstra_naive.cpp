/*
 * ============================================
 *   Dijkstra (朴素版) - 单源最短路
 *   目的：计算从 "起点 1" 到 "终点 n"（以及图中所有其他点）的最短距离。
 *   
 *   【实际场景举例：高德地图导航】
 *   - 你在上海 (起点 1)。
 *   - 你要去各个城市：苏州(2), 杭州(3), 南京(4)...
 *   - 这里的代码就是通过已知的公路网 (g[a][b])，算出来：
 *     去苏州最近要走多少公里？去杭州最近要走多少公里？
 * 
 *   【程序输入】
 *   3 3   (3个城市，3条路)
 *   1 2 2 (城市1->城市2，距离2公里)
 *   2 3 1 (城市2->城市3，距离1公里)
 *   1 3 4 (城市1->城市3，距离4公里)
 * 
 *   【程序输出】
 *   3     (从1去3的最短距离。虽然直达是4，但走1->2->3只要2+1=3，更近！)
 * ============================================
 */

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

// 为什么是 510？因为朴素版 Dijkstra 复杂度是 O(N^2)。
// N=500 时，500^2 = 25万次运算，非常快。
// 如果 N=10万，N^2=100亿，电脑跑不动，就得换算法了（下一节的堆优化）。
const int N = 510; 

int n, m;      // n: 城市数量, m: 公路数量
int g[N][N];   // [地图手册] g[1][2]=5 表示 城市1到2直达距离为5。g[1][3]=无穷大 表示不通。
int dist[N];   // [路程表] 记录“目前发现的”从起点(1号)到各个城市的最短距离。
bool st[N];    // [打卡表] st[3]=true 表示城市3的最短路已经完全确定，不用再检查了。
int pre[N];    // [路径记录] pre[j]=t 表示：j 是从 t 走过来的。用于最后打印路径。

int dijkstra()
{
    // [初始化阶段]
    // 刚开始，除了自己在原点，去哪都是一脸懵逼(无穷远)。
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0; // 我就在1号城市，距离当然是0

    // [核心循环]
    // 有 n 个城市，我们每一轮循环都能确定一个城市的最短路。
    // 就像剥洋葱，一圈一圈向外确定。
    for (int i = 0; i < n; i ++ )
    {
        int t = -1; // t 代表：这一轮我们选出的“距离起点最近的未打卡城市”

        // [模块 1：选点]
        // 目标：在所有还没打卡(!st[j])的城市里，找一个目前的 dist[j] 最小的。
        // 第一次循环时，肯定选中起点 1 (距离0)。
        for (int j = 1; j <= n; j ++ )
        {
            if (!st[j]) // 必须是没确定过的点
            {
                // 如果 t 还没选，或者 j 比 t 更近，那就选 j
                if (t == -1 || dist[t] > dist[j])
                    t = j;
            }
        }

        // 如果连最近的城市都是无穷远，说明剩下的城市根本走不过去（比如在海对岸的孤岛）。
        // 直接退出循环。
        if(dist[t] == 0x3f3f3f3f) break;

        // [模块 2：打卡]
        // 我们确信：目前离起点最近的这个 t，不可能再被绕远路更新了。
        // (因为所有边权都是正的，绕路只会更远)
        st[t] = true;

        // [模块 3：松弛 (关键!)]
        // t 既然已经确定了，我们就站在 t 城市，看看它的周边。
        // 比如 t->j 有一条路，全长 g[t][j]。
        // 我们比较：
        //   方案A: (目前的dist[j]) 比如原来的路是 1->3 直达距离 4
        //   方案B: (dist[t] + g[t][j]) 现在的路是 1->2->3 距离 2+1=3
        // 如果方案B更短，就更新 dist[j]。
        for (int j = 1; j <= n; j ++ )
        {
            // dist[j] = min(dist[j], dist[t] + g[t][j]);
            // 为了记录路径，我们展开写：
            if (dist[j] > dist[t] + g[t][j])
            {
                dist[j] = dist[t] + g[t][j];
                pre[j] = t; // 记录：如果要在这个距离到达 j，上一步必须是 t
            }
        }
    }

    // 题目通常问的是：从 1 号点到 n 号点的距离。
    // 如果 dist[n] 还是无穷大，说明断路了，返回 -1。
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

void print_path()
{
    if (dist[n] == 0x3f3f3f3f) return;
    
    int path[N], cnt = 0;
    int curr = n;
    while (curr != 0) // 从终点倒推回起点 (pre[1] = 0)
    {
        path[cnt ++ ] = curr;
        curr = pre[curr];
    }
    
    printf("【路径还原】: ");
    for (int i = cnt - 1; i >= 0; i -- )
        printf("%d%s", path[i], i == 0 ? "" : " -> ");
    printf("\n");
}

int main()
{
    // 读入城市数 n, 道路数 m
    scanf("%d%d", &n, &m);

    // [地图初始化]
    // 把所有路都设为无穷大，表示互不连通
    memset(g, 0x3f, sizeof g);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        
        // [存图细节]
        // 可能输入两行：1->2 距离 5； 1->2 距离 3。
        // 我们当然只记那条短的 (距离 3)。
        g[a][b] = min(g[a][b], c);
    }

    // 开始计算！
    int result = dijkstra();
    printf("%d\n", result);

    if (result != -1) print_path();

    return 0;
}

/*
 * =========================================================================
 * 【Dijkstra 手动模拟日志：一次去往罗马的旅程】
 * 
 * 地图数据 (N=5):
 * 1->2 (2km)
 * 1->3 (5km) (这是一条远路，故意迷惑你的)
 * 2->3 (2km) (经过2中转去3，总共2+2=4，比直达5近！)
 * 2->4 (6km)
 * 3->4 (1km) (这又是一条捷径)
 * 4->5 (3km)
 * 3->5 (8km) (远路)
 * 
 * 初始状态表 (dist):
 * [1号]: 0 (起点)
 * [2号]: ∞
 * [3号]: ∞
 * [4号]: ∞
 * [5号]: ∞
 * 
 * -------------------------------------------------------------------------
 * ROUND 1 (i=0):
 *   [选点]: 扫描所有点。只有 dist[1]=0 最小。-> **选中 1号**。
 *   [打卡]: st[1] = true。
 *   [松弛]: 站在 1号 看邻居：
 *          - 看到 2号：dist[2] 更新为 min(∞, 0+2) = 2。
 *          - 看到 3号：dist[3] 更新为 min(∞, 0+5) = 5。
 *   [当前状态]: {1:0, 2:2, 3:5, 4:∞, 5:∞}，VIP={1}
 * -------------------------------------------------------------------------
 * ROUND 2 (i=1):
 *   [选点]: 未打卡点里谁最近？
 *          dist[2]=2, dist[3]=5, ... -> **选中 2号**。
 *   [打卡]: st[2] = true。(这意味着去2号最短只能是2km了，不可能更短)
 *   [松弛]: 站在 2号 看邻居：
 *          - 看到 3号：dist[3] 原来是5。现在走 1->2->3 是 2+2=4。**更新为 4！**
 *          - 看到 4号：dist[4] 更新为 min(∞, 2+6) = 8。
 *   [当前状态]: {1:0, 2:2, 3:4(变短了!), 4:8, 5:∞}，VIP={1, 2}
 * -------------------------------------------------------------------------
 * ROUND 3 (i=2):
 *   [选点]: 未打卡点里谁最近？
 *          dist[3]=4, dist[4]=8... -> **选中 3号**。
 *   [打卡]: st[3] = true。
 *   [松弛]: 站在 3号 看邻居：
 *          - 看到 4号：dist[4] 原来是8。现在走 1->2->3->4 是 4+1=5。**更新为 5！**
 *          - 看到 5号：dist[5] 更新为 min(∞, 4+8) = 12。
 *   [当前状态]: {1:0, 2:2, 3:4, 4:5(变短了!), 5:12}，VIP={1, 2, 3}
 * -------------------------------------------------------------------------
 * ROUND 4 (i=3):
 *   [选点]: 未打卡点里谁最近？
 *          dist[4]=5, dist[5]=12... -> **选中 4号**。
 *   [打卡]: st[4] = true。
 *   [松弛]: 站在 4号 看邻居：
 *          - 看到 5号：dist[5] 原来是12。现在走 ...->4->5 是 5+3=8。**更新为 8！**
 *   [当前状态]: {1:0, 2:2, 3:4, 4:5, 5:8(变短了!)}，VIP={1, 2, 3, 4}
 * -------------------------------------------------------------------------
 * ROUND 5 (i=4):
 *   [选点]: 还没入选的只有 5号了。dist[5]=8。
 *   [打卡]: st[5] = true。
 *   [松弛]: 5号没有邻居了(或者没有更远的路了)。
 *   [最终状态]: dist[5]=8。
 * -------------------------------------------------------------------------
 * 
 * 最终答案：8。
 * 路径虽然没存，但是我们也看出来了：1->2->3->4->5。
 */
