/*
 * ============================================
 *   Dijkstra (朴素版) - 单源最短路
 *   时间复杂度：O(N^2)
 *   适用场景：稠密图 (边数 M 近似 N^2)，且边权都为正
 * ============================================
 * 
 * 【物理模型：雷达扫描】
 *   想象你在地图上的起点 (Start) 开启了一个雷达。
 *   这个雷达每一轮扫描，都能确定一个“最近的未探索城市”。
 *   
 *   为什么？因为如果 A 是所有未探索城市里最近的，
 *   而且所有路的距离都是正数，那么绝不可能存在一条路：
 *   Start -> B -> ... -> A 比 Start -> A 更短。
 *   (因为 Start->B 已经比 Start->A 长了)
 * 
 *   所以，Dijkstra 的本质是【贪心】：
 *   每次都把手伸向离自己最近的那个未知点，把它标记为“已探索”，
 *   然后站在这个新点上，看看能不能通过它，把去其他点的路变短 (松弛操作)。
 * 
 * 【核心数据结构】
 *   1. dist[N]: 距离数组。
 *      dist[i] 表示从起跑线 (节点1) 到节点 i 的当前最短推测距离。
 *      初始化为无穷大 (0x3f3f3f3f)，起跑线 dist[1] = 0。
 * 
 *   2. st[N]: 状态数组 (State)。
 *      st[i] = true 表示节点 i 的最短路已经彻底确定了 (收录进集合S)。
 *      st[i] = false 表示节点 i 还在观察期。
 * 
 *   3. g[N][N]: 邻接矩阵 (Adjacency Matrix)。
 *      因为是稠密图 (边特别多)，用矩阵存更方便 (g[a][b] = w)。
 *      如果是稀疏图，我们会改用邻接表 + 堆优化 (下一节讲)。
 * 
 * 【算法流程】
 *   循环 n 次，每次确定一个点：
 *   1. [选点]: 在所有 st[j]==false (未确定) 的点中，
 *             找一个 dist[j] 最小的点 t。
 *   2. [收录]: 标记 st[t] = true (点 t 的命运已定，它就是最近的)。
 *   3. [松弛]: 遍历 t 的所有出边 (t -> j)，
 *             看看能不能借道 t，让 1->...->t->j 比 1->...->j 更短？
 *             如果是，更新 dist[j] = dist[t] + g[t][j]。
 */

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 510; // 点的个数上限 (朴素版一般用于 N <= 500)

int n, m;
int g[N][N];   // 邻接矩阵：因为 N 比较小，用 g[a][b] 存 a->b 的权重
int dist[N];   // 距离数组：存起点到各点的距离
bool st[N];    // 状态数组：true 表示该点的最短路已经确定

int dijkstra()
{
    // 1. 初始化距离为正无穷 (0x3f3f3f3f 是一个很大的数，且防止加法溢出)
    memset(dist, 0x3f, sizeof dist);
    
    // 起点到自己的距离是 0
    dist[1] = 0;

    // 2. 迭代 n 次，每次确定一个点的最短距离
    for (int i = 0; i < n; i ++ )
    {
        int t = -1; // t 存储当前未确定点中，距离最近的那个点

        // [选点阶段]
        // 遍历所有点 j
        for (int j = 1; j <= n; j ++ )
        {
            // 如果点 j 还没有确定最短路 (st[j] == false)
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
            {
                // 如果 t 还没选，或者 j 比 t 更近，那就把 t 更新为 j
                t = j;
            }
        }

        // 如果找到的最近点距离仍然是无穷大，说明剩下的点都不可达，可以提前结束
        if(dist[t] == 0x3f3f3f3f) break;

        // [收录阶段]
        // 找到的 t 就是这一轮的“冠军”，它的最短路已经尘埃落定
        st[t] = true;

        // [松弛阶段]
        // 用这个新确定的点 t，去更新其他所有点 j 的距离
        for (int j = 1; j <= n; j ++ )
        {
            // 核心公式：dist[j] = min(目前的dist[j], 从起点走到t再走到j)
            dist[j] = min(dist[j], dist[t] + g[t][j]);
        }
    }

    // 题目要求：如果距离是无穷大，说明不可达，返回 -1
    // 0x3f3f3f3f 是我们在 memset 里设定的无穷大值
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main()
{
    scanf("%d%d", &n, &m);

    // 初始化邻接矩阵为无穷大 (memset按字节赋值，0x3f 也就成了很大的数)
    memset(g, 0x3f, sizeof g);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        
        // 这里的图可能有重边 (a->b 有多条路)，我们只保留最短的那条
        g[a][b] = min(g[a][b], c);
    }

    printf("%d\n", dijkstra());

    return 0;
}
