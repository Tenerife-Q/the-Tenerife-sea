/*
 * ============================================
 *   Dijkstra (朴素版) - 单源最短路
 *   目的：计算从 "起点 1" 到 "终点 n"（以及图中所有其他点）的最短距离。
 *   
 *   【实际场景举例：高德地图导航】
 *   - 你在上海 (起点 1)。
 *   - 你要去各个城市：苏州(2), 杭州(3), 南京(4)...
 *   - 这里的代码就是通过已知的公路网 (g[a][b])，算出来：
 *     去苏州最近要走多少公里？去杭州最近要走多少公里？
 * 
 *   【程序输入】
 *   3 3   (3个城市，3条路)
 *   1 2 2 (城市1->城市2，距离2公里)
 *   2 3 1 (城市2->城市3，距离1公里)
 *   1 3 4 (城市1->城市3，距离4公里)
 * 
 *   【程序输出】
 *   3     (从1去3的最短距离。虽然直达是4，但走1->2->3只要2+1=3，更近！)
 * ============================================
 */

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

// 为什么是 510？因为朴素版 Dijkstra 复杂度是 O(N^2)。
// N=500 时，500^2 = 25万次运算，非常快。
// 如果 N=10万，N^2=100亿，电脑跑不动，就得换算法了（下一节的堆优化）。
const int N = 510; 

int n, m;      // n: 城市数量, m: 公路数量
int g[N][N];   // [地图手册] g[1][2]=5 表示 城市1到2直达距离为5。g[1][3]=无穷大 表示不通。
int dist[N];   // [路程表] 记录“目前发现的”从起点(1号)到各个城市的最短距离。
bool st[N];    // [打卡表] st[3]=true 表示城市3的最短路已经完全确定，不用再检查了。
int pre[N];    // [路径记录] pre[j]=t 表示：j 是从 t 走过来的。用于最后打印路径。

int dijkstra()
{
    // [初始化阶段]
    // 刚开始，除了自己在原点，去哪都是一脸懵逼(无穷远)。
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0; // 我就在1号城市，距离当然是0

    // [核心循环]
    // 有 n 个城市，我们每一轮循环都能确定一个城市的最短路。
    // 就像剥洋葱，一圈一圈向外确定。
    for (int i = 0; i < n; i ++ )
    {
        int t = -1; // t 代表：这一轮我们选出的“距离起点最近的未打卡城市”

        // [模块 1：选点]
        // 目标：在所有还没打卡(!st[j])的城市里，找一个目前的 dist[j] 最小的。
        // 第一次循环时，肯定选中起点 1 (距离0)。
        for (int j = 1; j <= n; j ++ )
        {
            if (!st[j]) // 必须是没确定过的点
            {
                // 如果 t 还没选，或者 j 比 t 更近，那就选 j
                if (t == -1 || dist[t] > dist[j])
                    t = j;
            }
        }

        // 如果连最近的城市都是无穷远，说明剩下的城市根本走不过去（比如在海对岸的孤岛）。
        // 直接退出循环。
        if(dist[t] == 0x3f3f3f3f) break;

        // [模块 2：打卡]
        // 我们确信：目前离起点最近的这个 t，不可能再被绕远路更新了。
        // (因为所有边权都是正的，绕路只会更远)
        st[t] = true;

        // [模块 3：松弛 (关键!)]
        // t 既然已经确定了，我们就站在 t 城市，看看它的周边。
        // 比如 t->j 有一条路，全长 g[t][j]。
        // 我们比较：
        //   方案A: (目前的dist[j]) 比如原来的路是 1->3 直达距离 4
        //   方案B: (dist[t] + g[t][j]) 现在的路是 1->2->3 距离 2+1=3
        // 如果方案B更短，就更新 dist[j]。
        for (int j = 1; j <= n; j ++ )
        {
            // dist[j] = min(dist[j], dist[t] + g[t][j]);
            // 为了记录路径，我们展开写：
            if (dist[j] > dist[t] + g[t][j])
            {
                dist[j] = dist[t] + g[t][j];
                pre[j] = t; // 记录：如果要在这个距离到达 j，上一步必须是 t
            }
        }
    }

    // 题目通常问的是：从 1 号点到 n 号点的距离。
    // 如果 dist[n] 还是无穷大，说明断路了，返回 -1。
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
/*
int dijsktra(){
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for(int i = 0; i < n; i ++ ) {
        int t = -1; 每轮都要重新选一个点，所以 t 需要重置
        for(int j = 1; j <= n; j ++ ) {
            if(!st[j]) {
                if(t == -1 || dist[t] > dist[j]){ 
                这里注意顺序，先判断t==-1，再比较dist[t]和dist[j]，否则t=-1时会访问dist[-1]，越界访问。
                    t = j;
                } 
            }
        }

        if(dist[t] == 0x3f3f3f3f) break;

        st[t] = true;

        for(int j = 1; j <= n; j ++ ) {
            if(dist[j] > dist[t] + g[t][j]) {
                dist[j] = dist[t] + g[t][j];
                pre[j] = t;
            }
        }
    }
}
*/


void print_path()
{
    if (dist[n] == 0x3f3f3f3f) return;
    
    int path[N], cnt = 0;
    int curr = n;
    while (curr != 0) // 从终点倒推回起点 (pre[1] = 0)
    {
        path[cnt ++ ] = curr;
        curr = pre[curr];
    }
    
    printf("【路径还原】: ");
    for (int i = cnt - 1; i >= 0; i -- )
        printf("%d%s", path[i], i == 0 ? "" : " -> ");
    printf("\n");
}

int main()
{
    // 读入城市数 n, 道路数 m
    scanf("%d%d", &n, &m);

    // [地图初始化]
    // 把所有路都设为无穷大，表示互不连通
    memset(g, 0x3f, sizeof g);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        
        // [存图细节]
        // 可能输入两行：1->2 距离 5； 1->2 距离 3。
        // 我们当然只记那条短的 (距离 3)。
        g[a][b] = min(g[a][b], c);
    }

    // 开始计算！
    int result = dijkstra();
    printf("%d\n", result);

    if (result != -1) print_path();

    return 0;
}

/*
 * =========================================================================
 * 【Dijkstra 手动模拟日志：从 1 到 6 的复杂旅途】
 * 
 * 地图数据 (N=6):
 * 1->2 (2km)
 * 1->3 (4km) [直线去3]
 * 2->3 (1km) [绕路去3：1->2->3 总长3，这里比直达近！]
 * 2->4 (2km)
 * 3->5 (3km)
 * 4->5 (1km) [捷径！]
 * 4->6 (2km) [直达终点]
 * 5->6 (2km)
 * 
 * 初始状态表 (dist):
 * [1]:0, [2]:∞, [3]:∞, [4]:∞, [5]:∞, [6]:∞
 * st[]: 都在 false
 * 
 * -------------------------------------------------------------------------
 * ROUND 1 (i=0):
 *   [选点]: 还没确定的人里，dist[1]=0 最小。-> **选中 1号**。
 *   [打卡]: st[1] = true。
 *   [松弛]: 站在 1号 看邻居：
 *          - 1->2 (2km): dist[2] 更新为 2。 pre[2]=1。
 *          - 1->3 (4km): dist[3] 更新为 4。 pre[3]=1。
 *   [当前状态]: {1:0, 2:2, 3:4, 4:∞, 5:∞, 6:∞}，已确定={1}
 * -------------------------------------------------------------------------
 * ROUND 2 (i=1):
 *   [选点]: 剩下 {2(2), 3(4), ...}。 dist[2]=2 最小。-> **选中 2号**。
 *   [打卡]: st[2] = true。
 *   [松弛]: 站在 2号 看邻居：
 *          - 2->3 (1km): 目前 dist[3]=4。新方案 1->2->3 长度 2+1=3。
 *             ! 发现更短路！ dist[3] 更新为 3。 pre[3]=2 (原来是1)。
 *          - 2->4 (2km): dist[4] 更新为 2+2=4。 pre[4]=2。
 *   [当前状态]: {1:0, 2:2, 3:3(变短), 4:4, 5:∞, 6:∞}，已确定={1, 2}
 * -------------------------------------------------------------------------
 * ROUND 3 (i=2):
 *   [选点]: 剩下 {3(3), 4(4), ...}。 dist[3]=3 最小。-> **选中 3号**。
 *   [打卡]: st[3] = true。
 *   [松弛]: 站在 3号 看邻居：
 *          - 3->5 (3km): dist[5] 更新为 3+3=6。 pre[5]=3。
 *   [当前状态]: {1:0, 2:2, 3:3, 4:4, 5:6, 6:∞}，已确定={1, 2, 3}
 * -------------------------------------------------------------------------
 * ROUND 4 (i=3):
 *   [选点]: 剩下 {4(4), 5(6), 6(∞)}。 dist[4]=4 最小。-> **选中 4号**。
 *   [打卡]: st[4] = true。
 *   [松弛]: 站在 4号 看邻居：
 *          - 4->6 (2km): dist[6] 更新为 4+2=6。 pre[6]=4。
 *          - 4->5 (1km): 目前 dist[5]=6。新方案 ...->4->5 长度 4+1=5。
 *             ! 发现更短路！ dist[5] 更新为 5。 pre[5]=4 (原来是3)。
 *   [当前状态]: {1:0, 2:2, 3:3, 4:4, 5:5(变短), 6:6}，已确定={1, 2, 3, 4}
 * -------------------------------------------------------------------------
 * ROUND 5 (i=4):
 *   [选点]: 剩下 {5(5), 6(6)}。 dist[5]=5 最小。-> **选中 5号**。
 *   [打卡]: st[5] = true。
 *   [松弛]: 站在 5号 看邻居：
 *          - 5->6 (2km): 目前 dist[6]=6。新方案 ...->5->6 长度 5+2=7。
 *             ! 7 > 6，不更新！说明从5过去反而绕远了。
 *   [当前状态]: {1:0, 2:2, 3:3, 4:4, 5:5, 6:6}，已确定={1, 2, 3, 4, 5}
 * -------------------------------------------------------------------------
 * ROUND 6 (i=5):
 *   [选点]: 剩下 {6(6)}。-> **选中 6号**。
 *   [打卡]: st[6] = true。终点已确定。
 * 
 * 最终答案：dist[6] = 6。
 * 路径: 1 -> 2 -> 4 -> 6。
 * (注意：虽然 4->5->6 看起来很近，但是 4+1+2=7，不如 4->6 直接走=6)
 * =========================================================================
 */
