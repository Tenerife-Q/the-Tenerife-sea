/*
 * ============================================
 *   哈希表 (Hash Table): 高频查找的终极武器
 *   题目来源: AcWing 840. 模拟散列表
 * ============================================
 * 
 * 【物理视角的本质】
 *   哈希表的作用极其纯粹：把庞大且分散的数据（跨度10^9），映射到一个很小的、
 *   从 0 开始的连续数组下标里（10^5），从而实现 O(1) 的超高频查找。
 * 
 *   核心挑战：哈希冲突 (Collision)。
 *   解决方法：拉链法 (Separate Chaining) —— 本代码采用。
 * 
 * 【核心思路 - 拉链法】
 *   本质上就是开了一个大数组 h[N]，数组的每一个格子 h[k] 都是一个单链表的"头节点"。
 *   - h[k]: 哈希桶（存的是头节点的 idx）。
 *   - e[idx], ne[idx], idx: 也就是我们之前学的单链表内存池。
 *   - 冲突解决: 算出来都在 k 坑位的人，统统用"头插法"挂在 h[k] 下面。
 * 
 * 【复杂度】
 *   - 时间: 期望 O(1)。最坏情况退化为 O(N) (链表极长时)。
 */

#include <iostream>
#include <cstring>

using namespace std;

// N 取大于 100000 的第一个质数，能极大降低哈希冲突率
const int N = 100003;

// h[N]: 哈希桶 (Heads)
// e[], ne[], idx: 单链表三剑客
int h[N], e[N], ne[N], idx;

// 插入操作
void insert(int x) {
    // 1. 算哈希值 k (C++中负数取模还是负数，所以要加N再模N，保证结果为正)
    int k = (x % N + N) % N;
    
    // 2. 熟悉的单链表头插法！挂在哈希桶 h[k] 的下面
    // 物理动作拆解：
    // 1. e[idx] = x;    // e[idx] 存储真实节点的值 x。
    // 2. ne[idx] = h[k]; // ne[idx] 存储新节点的 next 指针，指向原来 h[k] 的头节点。
    // 3. h[k] = idx;    // h[] (头指针数组)：h[k] 代表第 k 个桶。
    //    里面存的是一个整数，这个整数是该桶对应的单链表的“头节点地址（idx）”。
    // 4. idx++ ;        // 内存池后移，准备接待下一位客人。
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx ++ ;
}

// 查询操作
bool find(int x) {
    // 1. 算出哈希值，定位到坑位 k
    int k = (x % N + N) % N;
    
    // 2. 顺着哈希桶 h[k] 这条单链表往下找
    for (int i = h[k]; i != -1; i = ne[i]) {
        if (e[i] == x) return true; // 找到了
    }
    return false; // 找遍了链表都没找到
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    // 初始化所有哈希桶为空链表 (-1)
    // memset 按字节赋值，-1 的补码是全 1，所以 int 也是 -1
    memset(h, -1, sizeof h);

    int n;
    cin >> n;
    while (n -- ) {
        char op[2];
        int x;
        cin >> op >> x;
        if (*op == 'I') insert(x);
        else {
            if (find(x)) cout << "Yes" << endl;
            else cout << "No" << endl;
        }
    }

    return 0;
}
/*
void insert(int x) {
    int k = (x % N +N) % N;
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx++;
}

bool find(int x) {
    int k = (x % N +N) % N;
    for(int i = h[k]; i != -1; i = ne[i]) {
        if(e[i] == x) return true;
    }
    return false;
}
*/


/*
 * ==================================================================================
 * 🔍 深度辨析：哈希冲突的两种流派
 * ==================================================================================
 * 
 * 1. 拉链法 (Separate Chaining) —— "单链表大军" (本文件)
 * ------------------------------------------------------------------
 *    - 物理直觉：h[k] 是一个坑位的专属 head 指针。谁的哈希值算出来是 k，
 *      谁就去 h[k] 这个单链表里排队。绝不干涉别人！
 *    - 优点：非常稳定，对"删除"操作友好。
 *    - 缺点：涉及链表指针，Cache Miss 略高。
 * 
 * 2. 开放寻址法 (Open Addressing) —— "暴力占坑法" (Backup Plan)
 * ------------------------------------------------------------------
 *    - 物理直觉：厕所坑位法。
 *      如果 h[k] 这个坑被别人占了，我就往后看 h[k+1]，直到找到空坑为止。
 *    - 只需要一个数组 h[N]，没有链表！
 *    - 核心巡逻函数 find(x):
 *      int find(int x) {
 *          int k = ...;
 *          while (h[k] != null && h[k] != x) { // 有人且不是自己
 *              k++;
 *              if (k == N) k = 0; // 循环查找
 *          }
 *          return k; // 返回找到的位置，或者空坑的位置
 *      }
 *    - 优点：极度优雅！内存连续性完美，速度极快！
 *    - 缺点：对数组大小敏感 (必须开 2~3 倍大)。
 * 
 * 3. 决策建议
 * ------------------------------------------------------------------
 *    - 追求绝对稳定、代码逻辑复用单链表 -> 选【拉链法】。
 *    - 追求极致精简、不愿意写链表结构体 -> 选【开放寻址法】。
 *    - 虽然开放寻址法代码更短，但拉链法在处理高负载冲突时表现更加稳健。
 *      在没得选的情况下，建议背诵【拉链法】，因为它就是单链表的自然延伸。
 */


/*
 * ==================================================================================
 * 🔍 深度辨析：把 5 行代码扒个精光
 * ==================================================================================
 * 
 * 1. 哈希函数设计
 * -----------------------------------------------------------
 *   k = (x % N + N) % N
 *   - 目的: 将任意整数 x 映射到 [0, N-1] 的范围内。
 *   - 为什么加 N? 因为 C++ 中的取模运算对负数结果也是负数。加 N 保证结果非负。
 *   - 为什么再取模? 因为加 N 后可能超过 N，需要再次取模回到范围内。比如 x = 5, N = 3:
 *     如果最后不取模，k = 5 % 3 + 3 = 2 + 3 = 5 (错误，超出范围)
 *     正确的计算应该是 k = (5 % 3 + 3) % 3 = (2 + 3) % 3 = 5 % 3 = 2 (正确，映射到 [0, N-1])
 * 
 *   - 例子: x = -1, N = 100003
 *     k = (1 % 100003 + 100003) % 100003
 *       = (1 + 100003) % 100003
 *       = 100004 % 100003
 *       = 1 (正确映射到 [0, N-1])
 * 
 * 
 * 2. 内存动作大揭秘 (Memory Actions of Head Insertion)
 * -----------------------------------------------------------
 *    数组模拟链表的核心四步走：
 *    
 *    (1) e[idx] = x;    // 【造新节点】
 *        物理含义：在内存池 idx 处申请一块地，存入值 x。
 *        对比 OOP:  Node* p = new Node(); p->val = x;
 * 
 *    (2) ne[idx] = h[k]; // 【新节点指旧头】
 *        物理含义：新人的手抓着原来排第一的人。
 *        对比 OOP:  p->next = head[k];
 * 
 *    (3) h[k] = idx;    // 【更新头节点】
 *        物理含义：站牌 h[k] 现在指向新人 idx。
 *        对比 OOP:  head[k] = p;
 * 
 *    (4) idx++;         // 【内存池后移】
 *        物理含义：当前号码已用，准备接待下一位客人。
 * 
 *    * 为什么是头插不是尾插？
 *      尾插需要遍历整个链表找尾巴 (O(N))，头插永远只动头 (O(1))。
 *      而在哈希表中，我们只在乎存在性，不在乎插入顺序。
 * 
 * 3. 帧动画实战：冲突解决 (Collision Resolution Trace)
 * -----------------------------------------------------------
 *    假设 h[2] 初始为 -1 (NULL), idx=0。依次插入 15, 25, 35 (假设 hash 都是 2)。
 * 
 *    [T1: 插入 15]
 *    e[0]=15; ne[0]=-1; h[2]=0; idx变成1。
 *    链表: 15 -> NULL
 * 
 *    [T2: 插入 25 (冲突)]
 *    e[1]=25; ne[1]=h[2](即0); h[2]=1; idx变成2。
 *    链表: 25 -> 15 -> NULL (25 插到了前面!)
 * 
 *    [T3: 插入 35 (再冲突)]
 *    e[2]=35; ne[2]=h[2](即1); h[2]=2; idx变成3。
 *    链表: 35 -> 25 -> 15 -> NULL
 * 
 *    [物理内存快照]:
 *    idx:  0   1   2
 *    e:  [15, 25, 35] (连续存储)
 *    ne: [-1,  0,  1] (逻辑回溯指针)
 *    h[2]: 2 (指向最新的 35)
 */