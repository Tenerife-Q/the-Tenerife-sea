/*
 * ============================================
 *   单调队列 (Monotonic Queue) - 滑动窗口
 *   题目来源: AcWing 154. 滑动窗口
 * ============================================
 * 
 * 【问题】
 *   给定一个大小为 n 的数组，有一个大小为 k 的滑动窗口从左移到右。
 *   求每时刻窗口内的最小值和最大值。
 * 
 * 【核心思路】
 *   - 使用双端队列（Deque）存储下标。
 *   - 求最小值：维护单调递增队列。
 *     1. 队头滑出窗口：if (hh <= tt && q[hh] < i - k + 1) hh++;
 *     2. 保持单调性：if (a[q[tt]] >= a[i]) tt--;
 *     3. 入队：q[++tt] = i;
 *     4. 输出：a[q[hh]];
 *   - 求最大值：维护单调递减队列（类似）。
 * 
 * 【复杂度】
 *   - O(n)，每个元素进队一次出队一次。
 */

#include <iostream>

using namespace std;

const int N = 1000010;

int n, k;
int a[N];   // 原数组
int q[N];   // 单调队列 (存下标)

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> n >> k;
    for (int i = 0; i < n; i ++ ) cin >> a[i];

    // ==========================================
    // 任务1：求滑动窗口最小值 -> 维护单调递增队列
    //
    // 【流程示例】 k=3, a = {1, 3, -1, -3, 5}
    // i=0, x=1 : 队空 -> 1入队。q存下标{0}, 对应值{1}
    // i=1, x=3 : 3>=1, 满足递增 -> 3入队。q={0,1}, 对应值{1,3}
    // i=2, x=-1: -1<3, 3出; -1<1, 1出。q={2}, 对应值{-1} -> 输出队头 -1
    // i=3, x=-3: -3<-1, -1出。q={3}, 对应值{-3} -> 输出队头 -3
    // i=4, x=5 : 5>=-3, 满足递增 -> 5入队。q={3,4}, 对应值{-3,5} -> 输出队头 -3
    // ==========================================
    int hh = 0, tt = -1;
    for (int i = 0; i < n; i ++ ) {
        // 1. 判滑出: 队头下标 < 窗口左边界(i-k+1)
        if (hh <= tt && q[hh] < i - k + 1) hh ++ ;
        
        // 2. 维护单调递增: 
        //    核心逻辑：队尾 >= 当前值，就删队尾。
        //    (既然我要维持递增，比我大的必须滚蛋，直到队尾是个比我小的为止)
        while (hh <= tt && a[q[tt]] >= a[i]) tt -- ;
        
        // 3. 入队
        q[ ++ tt] = i;
        
        // 4. 输出队头(最小值)
        if (i >= k - 1) cout << a[q[hh]] << " ";
    }
    cout << endl;

    // ==========================================
    // 任务2：求滑动窗口最大值 -> 维护单调递减队列
    // ==========================================
    hh = 0, tt = -1;
    for (int i = 0; i < n; i ++ ) {
        // 1. 判滑出
        if (hh <= tt && q[hh] < i - k + 1) hh ++ ;
        
        // 2. 维护单调递减:
        //    核心逻辑：队尾 <= 当前值，就删队尾。
        //    (既然我要维持递减，比我小的必须滚蛋，直到队尾是个比我大的为止)
        while (hh <= tt && a[q[tt]] <= a[i]) tt -- ;
        q[ ++ tt] = i;

        if (i >= k - 1) cout << a[q[hh]] << " ";
    }
    cout << endl;

    return 0;
}

/*
for(int i = 0; i < n; i++ ) {
    if(hh <= tt && q[hh] < i -k +1) hh++;
    while(hh <= tt && a[q[tt]] >= a[i]) tt--;
    q[++tt] = i;
    if(i >= k-1) cout << a[q[hh]] << endl;
}
    关于几个数组的说明：
    - a[N]: 存储输入的原数组。
    - q[N]: 存储单调队列中的元素下标。
    - hh: 队头指针，指向当前单调队列的头部。
    - tt: 队尾指针，指向当前单调队列的尾部。
    1. 判滑出: if (hh <= tt && q[hh] < i - k + 1) hh++;
       - 判断当前队头元素是否已经滑出窗口范围。
       - 窗口左边界为 i - k + 1，如果队头下标 q[hh] 小于这个值，说明它已经不在当前窗口内了，需要将 hh 后移，弹出队头。
    2. 维护单调递增: while (hh <= tt && a[q[tt]] >= a[i]) tt--;
       - 维护单调递增队列的核心逻辑：如果当前元素 a[i] 小于等于队尾元素 a[q[tt]]，说明队尾元素不再可能是“左边第一个比后面某个数小”的候选项（因为a[i]更小且更靠右，优于队尾），所以需要将 tt 后移，弹出队尾。
       - 这个过程会持续进行，直到队尾元素小于当前元素 a[i]，或者队列为空。
    3. 入队: q[++tt] = i;
       - 将当前元素的下标 i 入队，成为新的队尾。
    4. 输出队头: if (i >= k - 1) cout << a[q[hh]] << " ";
       - 当 i 大于等于 k - 1 时，说明窗口已经形成，可以输出当前窗口的最小值了。此时队头 q[hh] 存储的是当前窗口内最小元素的下标，a[q[hh]] 就是这个最小值。
    5. 求最大值时，维护单调递减队列的逻辑类似，只需要将比较符号改为 <= 即可。
*/
