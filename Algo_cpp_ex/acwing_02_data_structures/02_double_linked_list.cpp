/*
 * ============================================
 *   双链表 (Double Linked List) - 数组模拟
 *   题目来源: AcWing 827. 双链表
 * ============================================
 * 
 * 【问题】
 *   实现一个双链表，支持在最左侧/最右侧插入，在第k个元素左右插入，以及删除操作。
 * 
 * 【核心思路】
 *   使用两个哨兵节点简化边界判断：
 *   - 下标 0: 左端点 (head)
 *   - 下标 1: 右端点 (tail)
 *   - 真实数据从下标 2 开始存储
 * 
 *   l[i]: 左指针 (prev)
 *   r[i]: 右指针 (next)
 * 
 * 【图解】
 *   [0] <==> [Node1] <==> [Node2] <==> [1]
 *   r[0]->Node1, l[1]->Node2
 * 
 * 【复杂度】
 *   - 所有操作均为 O(1)
 */

#include <iostream>
#include <string>

using namespace std;

const int N = 100010;

int m;
// e[]:节点值, l[]:左指针, r[]:右指针
// idx: 内存分配指针
//      - 从 2 开始 (0,1 被哨兵占用)
//      - 第 k 个插入的数的物理下标是 k+1
//      - 同样遵循"只增不减"原则
int e[N], l[N], r[N], idx;

// 初始化
/*
 * 哨兵就位，虚位以待
 * 下标 0: 左边界 (head, 左哨兵)
 * 下标 1: 右边界 (tail, 右哨兵)
 * idx = 2: 真实数据从2开始分配
 * 
 * 初始状态图示:
 * [0:Head] <======> [1:Tail]
 * r[0]=1            l[1]=0
 */
void init() {
    // 0是左端点，1是右端点
    r[0] = 1;
    l[1] = 0;
    idx = 2;
}

// 在下标为k的节点右边插入x
/*
 * 核心操作: 在节点 k 的右侧插入
 * 
 * 1. 新节点先伸出双手:
 *    r[idx] = r[k];  (新节点右手 -> 原k的右节点)
 *    l[idx] = k;     (新节点左手 -> k)
 * 
 * 2. 原链表断开旧手牵新手 (注意顺序!):
 *    l[r[k]] = idx;  (原k右节点的左手 -> 新节点)  <-- 必须先做! 否则 r[k] 变了就找不到右兄弟了
 *    r[k] = idx;     (k的右手 -> 新节点)
 * 
 * 图解:
 *       [k]  -------->  [Original_Next]
 *        ^                   ^
 *         \                 /
 *          ---- [idx] -----
 * 
 * 技巧: 在 k 左边插入等价于 add(l[k], x)
 */
void add(int k, int x) {
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;
    l[r[k]] = idx;
    r[k] = idx;
    idx ++ ;
}

// 删除下标为k的节点
/*
 * 核心操作: 让左右兄弟“越过”自己互相牵手
 * 
 * 1. 左兄弟的右手 -> 右兄弟
 * 2. 右兄弟的左手 -> 左兄弟
 * 
 * 图解:
 *    [l[k]] <== (skip k) ==> [r[k]]
 */
void remove(int k) {
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    init();

    cin >> m;

    /*
     * 关于 k + 1 的说明：
     * 第 1 个插入的数，系统分配 idx = 2
     * 第 2 个插入的数，系统分配 idx = 3
     * ...
     * 第 k 个插入的数，系统分配 idx = k + 1
     * 
     * 所以题目提到“第k个插入的数”时，对应物理下标均需 k+1
     */
    while (m -- ) {
        string op;
        cin >> op;
        int k, x;

        if (op == "L") {
            cin >> x;
            add(0, x); // 在0的右边插入，即最左侧
        }
        else if (op == "R") {
            cin >> x;
            add(l[1], x); // 在1的左边插入，即1的左边的节点的右边
        }
        else if (op == "D") {
            cin >> k;
            remove(k + 1); // 第k个插入的数下标是k+1 (因为0,1被占用了)
        }
        else if (op == "IL") {
            cin >> k >> x;
            add(l[k + 1], x); // 在k+1的左侧插入
        }
        else if (op == "IR") {
            cin >> k >> x;
            add(k + 1, x); // 在k+1的右侧插入
        }
    }

    // 从左向右输出 (不包含哨兵)
    for (int i = r[0]; i != 1; i = r[i]) {
        cout << e[i] << " ";
    }
    cout << endl;

    return 0;
}
