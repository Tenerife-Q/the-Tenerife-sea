/*
 * ============================================
 *   并查集 (Union-Find): 动态连通性的终极方案
 *   题目来源: AcWing 836. 合并集合
 * ============================================
 * 
 * 【极简之美】
 *   在所有的高级数据结构中，并查集是代码最短（核心5行）、但数学均摊复杂度最令人拍案叫绝的一个。
 *   它完美解决了图论中棘手的“动态连通性”问题（如 Kruskal 最小生成树）。
 * 
 * 【物理视角的本质区别】
 *   - Trie树: 指针从父节点“向下”指向子节点 (Downwards)。
 *   - 并查集: 每一个节点只认自己的“父节点”，指针是“向上”指的 (Upwards)！
 * 
 * 【核心接口】
 *   1. find(x): 寻找 x 的祖宗节点 + 路径压缩 (Path Compression)。
 *   2. merge(a, b): 将 a 所在的集合并入 b 所在的集合。
 * 
 * 【复杂度】
 *   - 时间复杂度: 近乎 O(1) (Ackermann函数的反函数，可视为常数)。
 */

#include <iostream>

using namespace std;

const int N = 100010;

int n, m;
// p[x]: 存储 x 的父节点编号 (这也是并查集唯一的物理载体)
// 如果 p[x] == x，说明 x 是祖宗 (根节点)
int p[N];

// 核心函数：返回 x 的祖宗节点 + 路径压缩
int find(int x) {
    // 如果我不是祖宗 (即 p[x] != x)
    if (p[x] != x) {
        // 【递归魔法】：不仅问我上司的祖宗是谁
        // 而且直接把我的上司"篡改"成那个最顶级的祖宗！
        p[x] = find(p[x]);
    }
    return p[x];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> n >> m;

    // 1. 初始化：每个人自成一派，上司是自己
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    while (m -- ) {
        char op[2];
        int a, b;
        cin >> op >> a >> b;

        if (op[0] == 'M') {
            // 合并集合：让 a 的祖宗认 b 的祖宗为父
            // 也就是把 a 所在的树嫁接到 b 所在的树上
            p[find(a)] = find(b);
        }
        else {
            // 查询是否在同一集合：只需比较祖宗是否相同
            if (find(a) == find(b)) cout << "Yes" << endl;
            else cout << "No" << endl;
        }
    }

    return 0;
}

/*
 * ==================================================================================
 * 🔍 深度辨析：把 5 行代码扒个精光
 * ==================================================================================
 * 
 * 一、 唯一的核心物理载体：p[] 数组
 * -----------------------------------------------------------
 *   在并查集里，世界上只有一种关系：“谁是我的直系上司？”
 *   - p[x] 的物理意义：节点 x 的父节点编号。
 *   - 最高准则：如果 p[x] == x，说明 x 没有上司，他就是“祖宗”，代表一个独立的集合。
 * 
 * 二、 灵魂函数：find(x) 与路径压缩 (Path Compression)
 * -----------------------------------------------------------
 *   这是并查集做到近乎 O(1) 的绝对核心。
 *   
 *   [原始版 find] (如果不优化):
 *     return p[x] == x ? x : find(p[x]);
 *     痛点：如果集合是 1->2->3->4，找 1 的祖宗要爬 5 次，退化成 O(N)。
 * 
 *   [路径压缩版 find] (本代码):
 *     if (p[x] != x) p[x] = find(p[x]);
 *     
 *     [物理动作拆解]:
 *     假设当前链条：1 -> 2 -> 3 (3是祖宗)。执行 find(1):
 *     1. 查 1: 上司是 2。递归 find(2)。
 *     2. 查 2: 上司是 3。递归 find(3)。
 *     3. 查 3: 是祖宗。返回 3。
 *     4. 回溯至 2: p[2] = 3 (没变)。返回 3。
 *     5. 回溯至 1: p[1] = 3 (!!!)。1 的上司直接从 2 变成了 3。
 *     
 *     [结果]: 下次再查 1，只需一步就能找到 3。树的高度瞬间被拍扁。
 * 
 * 三、 集合合并的误区
 * -----------------------------------------------------------
 *   错误写法：p[a] = b;
 *   后果：如果 a 下面还有一帮小弟，直接改 a 的上司为 b，a 原来的祖宗和家族体系会被撕裂。
 *   
 *   正确写法 (两军交战，主帅臣服):
 *   p[find(a)] = find(b);
 *   1. 找出 a 的主帅 A。
 *   2. 找出 b 的主帅 B。
 *   3. 让 A 认 B 为父 (p[A] = B)。
 *   这样 A 麾下的千军万马顺理成章地归顺了 B。
 * 
 * 四、 帧动画实战：p: [1, 2, 3, 4] (4人初始状态)
 * -----------------------------------------------------------
 *   1. M 1 2 (合并1,2):
 *      find(1)=1, find(2)=2 -> p[1]=2。
 *      [内存]: p=[2, 2, 3, 4]
 * 
 *   2. M 3 4 (合并3,4):
 *      find(3)=3, find(4)=4 -> p[3]=4。
 *      [内存]: p=[2, 2, 4, 4]
 * 
 *   3. M 1 3 (合并1,3):
 *      find(1) -> 查p[1]是2 -> 查p[2]是2(祖宗)。返回 2。
 *      find(3) -> 查p[3]是4 -> 查p[4]是4(祖宗)。返回 4。
 *      执行 p[2] = 4。
 *      [内存]: p=[2, 4, 4, 4]。树结构: 1->2->4, 3->4。
 * 
 *   4. Q 1 3 (查询1,3):
 *      find(1): 查p[1]=2 -> 查p[2]=4(祖宗)。路径压缩触发 p[1]=4。
 *      find(3): 查p[3]=4(祖宗)。
 *      结果：两人祖宗都是 4，Yes。
 *      [最终内存]: p=[4, 4, 4, 4]。树被完全拍扁。
 */

/*
 * ==================================================================================
 * 🧘 递归心法：彻底治好"递归恐惧症"
 * ==================================================================================
 * 
 * 很多人试图在脑子里像 CPU 一样压栈（Stack Push），这违反了人类大脑的工作原理。
 * 请使用以下两套思维模型来实现"降维打击"。
 * 
 * 心法一：黑盒信任法则 (The Leap of Faith) —— 放弃单步调试！
 * -----------------------------------------------------------
 * 理解递归的第一铁律：永远只关注"当前这一层"在干什么。
 * 把对下一层的调用当成一个绝对会成功的"黑盒接口"。
 * 
 *    if (p[x] != x) {
 *        // 【黑盒时刻】
 *        // 我不管 p[x] 是怎么去找祖宗的。
 *        // 我坚信：只要我调用 find(p[x])，它一定会把终极大 Boss 的名字给我送回来！
 *        p[x] = find(p[x]); 
 *    }
 * 
 * 心法二："递"与"归"的时间差原理 (微观拆解)
 * -----------------------------------------------------------
 * 递归 = 递去 (Pass) + 归来 (Return)。
 * 函数调用那一行代码是分水岭。
 * 
 *    1. 等号右边的 find(...) 是"递"。
 *       - 处于"挂起等待"状态。都在找人办事。
 * 
 *    2. 触底反弹（Base Case 触发）
 *       - 找到了祖宗，开始往回传值。
 * 
 *    3. 等号左边的 p[x] = ... 是"归"。
 *       - 拿到结果后，瞬间执行赋值操作。
 *       - 这就是路径压缩发生的时刻：每一层都在把上司改成大 Boss。
 * 
 * 总结：
 * 只要你放弃"我想知道 find 到底压了几层栈"的执念，这段代码逻辑就像喝水一样自然：
 * 我不是 Boss -> 我问上司要 Boss 名字 -> 我把上司改成 Boss -> 我把 Boss 名字告诉别人。
 *
 * 🧬 进化论：从原始思维到精简模板 (Hand-written Evolution)
 * ==================================================================================
 * 
 * 很多人觉得精简版模板难以记忆，是因为它跳过了逻辑推演。
 * 哪怕比赛时脑子短路，只要顺着"人类本能"的三步走，依然能写出绝对正确的代码。
 * 
 * [阶段一：本能直译] (Absolute Human Logic)
 * ----------------------------------------
 * int find(int x) {
 *    // 1. 本能一：我是不是老大？
 *    if (p[x] == x) {
 *        return x; // 是，交差。
 *    } 
 *    // 2. 本能二：不是，找上司要老大名字
 *    else {
 *        int boss = find(p[x]); // 递推
 *        p[x] = boss;           // 路径压缩
 *        return boss;           // 交差
 *    }
 * }
 * 
 * [阶段二：代码重构] (Refactoring)
 * ----------------------------------------
 * 发现无论走 if 还是 else，最后返回的都是 p[x]。提取公共部分。
 * 
 * int find(int x) {
 *    if (p[x] == x) { // 没动作，等最后 return
 *    } else {
 *        p[x] = find(p[x]); // 只有这里需要折腾
 *    }
 *    return p[x]; // 统一交差
 * }
 * 
 * [阶段三：终极压缩] (AcWing Template)
 * ----------------------------------------
 * 既然 if 里面什么都不做，那就反过来写条件！
 * 
 * int find(int x) {
 *     if (p[x] != x) p[x] = find(p[x]); // 只有不是老大，才去折腾
 *     return p[x];
 * }
 * 
 * 💪 肌肉记忆咒语 (Muscle Memory Mantra)
 * -------------------------------
 * 1. "写个函数名，传个 x。"
 * 2. "如果不一样，就把自己等于自己的 find。" (if p[x] != x, p[x] = find)
 * 3. "最后退回 p[x]。"
 */
