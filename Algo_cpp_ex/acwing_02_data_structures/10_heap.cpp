/*
 * ============================================
 *   堆 (Heap): 完全二叉树在一维数组中的完美映射
 *   题目来源: AcWing 838. 堆排序
 * ============================================
 * 
 * 【物理视角的本质】
 *   堆是一个完全二叉树，但我们不需要用 Node* left, right 指针来存。
 *   利用完全二叉树的性质，我们直接用一维数组 h[] 就能算出父子关系。
 *   - 节点 u 的左孩子: 2 * u
 *   - 节点 u 的右孩子: 2 * u + 1
 *   - 节点 u 的父节点: u / 2
 *   注意：下标必须从 1 开始！(从 0 开始算乘法比较麻烦)
 * 
 * 【图解】
 *      1
 *    /   \
 *   2     3
 * 
 * 【复杂度】
 *   - 建堆: O(N) (神奇的数学级数收敛)
 *   - 调整: O(log N)
 */

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, m;

// h[N]: heap 数组，存储堆中的元素。
// sz:   size，当前堆里有多少个元素。
int h[N], sz;


// 【核心操作：下沉 down】
// 物理意义：如果你发现自己比孩子大（德不配位），你就得下去，把小的孩子换上来。
// 就像石头丢进水里，一直沉到它该在的位置。
// 
// Q: 为什么 down() 常用递归实现？
// A: 因为通过判断左、右孩子和自身三者最小值，一旦交换发生，
//    原节点到了一个新的位置 t，在新位置它可能仍然不满足堆性质。
//    递归调用 down(t) 非常符合“在新环境重启检查”的语义。
void down(int u) {
    int t = u; // t 用于记录三个点 (u, 左孩子, 右孩子) 中值最小的那个下标
    
    // 1. 如果左孩子存在，且左孩子比我小，那最小下标 t 先暂时记为左孩子
    if (u * 2 <= sz && h[u * 2] < h[t]) t = u * 2;
    
    // 2. 如果右孩子存在，且右孩子比目前的 t 还要小，那 t 更新为右孩子
    if (u * 2 + 1 <= sz && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    
    // 3. 如果发现我自己 (u) 不是最小的 (t != u)，说明我需要下沉
    if (u != t) {
        swap(h[u], h[t]); // 我和最小的孩子交换位置
        down(t);          // 交换后我到了 t 的位置，但我可能还得继续沉，递归处理
    }
}

// 【辅助操作：上浮 up】
// 物理意义：如果你发现自己比父亲小（青出于蓝），你就得上去，取代父亲的位置。
// 就像气泡在水里上浮。
// 
// Q: 为什么 up() 常用循环实现？
// A: 它的路径是唯一的单行道（只往父节点走），不需要像 down 那样做三选一的分支决策。
//    while 循环写起来极其简洁。
void up(int u) {
    // 只要我有父亲 (u/2 > 0)，且我比父亲还小
    while (u / 2 && h[u / 2] > h[u]) {
        swap(h[u / 2], h[u]); // 我和父亲交换
        u /= 2;               // 我现在的坐标变成了父亲的坐标，继续往上看
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> n >> m;
    
    // 【模式区别】
    // 10_heap.cpp (本文件): 静态读入 -> 批量建堆(O(N)) -> 只处理输出/删除最小值
    // 13_heap_mapped.cpp:  动态读入 -> 逐个插入(O(logN)) -> 支持任意位置修改/删除
    
    // 读入数组 (下标从 1 开始！)
    for (int i = 1; i <= n; i ++ ) cin >> h[i];
    sz = n;

    // 【建堆魔法：O(n)】
    // 为什么从 n/2 开始？
    // 因为 n/2 是最后一个非叶子节点。叶子节点本身不需要 down。
    // 我们从下往上，倒着遍历每一个非叶子节点，执行 down。
    // 这样能保证每处理完一层，下面的子树都已经满足堆性质。
    for (int i = n / 2; i; i -- ) down(i);

    while (m -- ) {
        // 1. 输出堆顶 (最小值)
        cout << h[1] << " ";
        
        // 2. 删除堆顶
        // 方法：直接把堆底的那个元素 (h[sz]) 拿上来覆盖堆顶 (h[1])
        // 然后堆的大小减 1 (sz--)
        h[1] = h[sz];
        sz -- ;
        
        // 3. 此时堆顶是原来那个垫底的废柴，它肯定很大，需要大力下沉
        down(1);
    }
    cout << endl;

    return 0;
}

/*
 * ==================================================================================
 * 🔍 深度辨析：down 操作的物理图解
 * ==================================================================================
 * 
 * 假设此时堆的状态违背了小根堆性质：根节点是 9，左孩子 3，右孩子 5。
 * 
 *       (1) [9]  <-- 违规！它是最大值，却坐在了老大的位置
 *          /   \
 *      (2)[3]  (3)[5]
 * 
 * 执行 down(1):
 * 1. 比较 u=1(val=9), 2u=2(val=3), 2u+1=3(val=5)
 * 2. 发现 3 是最小的。t = 2。
 * 3. 交换 h[1] 和 h[2]。
 * 
 *       (1) [3]  <-- 3 上位成功，它是当前局部最小
 *          /   \
 *      (2)[9]  (3)[5]
 * 
 * 4. 递归 down(2)。继续检查 9 在新的位置是否合适...
 * 
 * ==================================================================================
 * 💡 深度追问：三个核心疑点解析
 * ==================================================================================
 * 
 * Q1: 堆是否保证"左孩子 < 右孩子"？
 * A1: 绝对不保证！堆只保证【父节点 <= 左右孩子】，兄弟之间谁大谁小无所谓。
 *     例: [1, 5, 3] 是完全合法的小根堆 (1<=5 且 1<=3)。它只保证局部有序。
 * 
 * Q2: 为什么建堆的时间复杂度是 O(N) 而不是 O(N log N)?
 * A2: (数学推导 - 错位相减法)
 *     假设总节点数 N ≈ 2^h。
 *     第 h-1 层(底层): 2^(h-1) 个节点，每个最多下沉 0 层 -> 工作量 0
 *     第 h-2 层:       2^(h-2) 个节点，每个最多下沉 1 层 -> 工作量 1 * 2^(h-2)
 *     ...
 *     第 0 层(根):     2^0 个节点，    每个最多下沉 h-1 层 -> 工作量 (h-1) * 2^0
 * 
 *     总工作量 S = 1*2^(h-2) + 2*2^(h-3) + ... + (h-1)*2^0
 *     利用错位相减法求和: 
 *       S  ≈ 2 * 2^h = 2N
 *     所以时间复杂度是线性的 O(N)。
 *     
 *     [直观理解]: 金字塔搬砖。
 *     绝大多数人(底层员工)都在第一层，根本不用搬(down)。
 *     虽然总经理(根节点)要搬很远，但他只有一个。
 *     少量的精英干重活，大量的底层不干活 -> 总工作量极低。
 * 
 * 
 * Q3: 删除堆顶为什么要"移花接木"？(h[1] = h[sz]; sz--; down(1);)
 * A3: 
 *     - 如果直接删除 h[1]，数组中间会产生空洞，移动后面所有元素是 O(N)，太慢！
 *     - 狸猫换太子策略:
 *       1. 把全公司最不起眼的临时工 (最后一个元素 h[sz]) 提拔到总经理位置 (h[1])。
 *       2. 裁掉原来的末尾位置 (sz--)，数组依然连续。
 *       3. 此时新总经理德不配位 (数值很大)，执行 down(1) 让他一路沉下去，直到合适的位置。
 *       4. 这一套操作仅需 O(log N)。
 * 
 * ==================================================================================
 * 💡 为什么下标必须从 1 开始？
 * ==================================================================================
 * 
 * 如果下标从 0 开始：
 * - 左孩子: 2*x + 1
 * - 右孩子: 2*x + 2
 * - 父节点: (x-1) / 2
 * 
 * 这种计算不仅写起来麻烦，而且涉及 +1/-1 的偏移，极易在某些边界条件下出错。
 * 
 * 如果下标从 1 开始：
 * - 左孩子: 2*x      (位运算 x << 1)
 * - 右孩子: 2*x + 1  (位运算 x << 1 | 1)
 * - 父节点: x / 2    (位运算 x >> 1)
 * 这种映射关系极其干净、对称，符合二进制的数学美感。
 */
