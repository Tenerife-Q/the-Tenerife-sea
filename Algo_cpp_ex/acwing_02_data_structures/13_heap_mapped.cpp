/*
 * ============================================
 *   带映射的堆 (Mapped Heap)
 *   核心思想：双向追踪雷达 + 堆的物理映射
 * ============================================
 * 
 * 【为什么需要带映射？】
 *   普通堆只能操作堆顶或通过值查找（慢）。
 *   如果题目要求：“请把第 k 个插入的数字修改为 x”或者“删除第 k 个插入的数”，
 *   普通堆就瞎了，因为它不知道第 k 个插入的数字现在被 swap 到了数组的哪个角落。
 * 
 * 【核心物理结构：双向追踪体系】
 *   除了存放真实数据的 h[N] 之外，新增两个雷达数组。
 *   务必把它们的**物理定义**刻在脑子里：
 * 
 *   1. ph[k] = idx (Pointer -> Heap)
 *      - 物理意义：第 k 个插入的数字，目前住在 h 数组的哪个物理房间 idx？
 *      - 作用：上帝视角找人。修改第 k 个数时，直接去 h[ph[k]] 抓他。
 * 
 *   2. hp[idx] = k (Heap -> Pointer)
 *      - 物理意义：目前住在物理房间 idx 里的这个数字，他的历史身份证号 k 是多少？
 *      - 作用：底层被迫换房时的反向通知。当 h[a] 和 h[b] 交换时，它们必须拿出各自的身份证，
 *            去修改系统里的 ph 记录。
 * 
 * 【灵魂操作：heap_swap(a, b)】
 *   这是整个带映射堆的绝对核心。
 *   不仅要交换数据 h[a] 和 h[b]，还要交换它们背后的身份信息。
 *   
 *   swap(ph[hp[a]], ph[hp[b]]); // 交换雷达 ph：让两个数字的“历史身份证”指向彼此的新房间
 *   swap(hp[a], hp[b]);         // 交换雷达 hp：让这两个房间记录下各自迎来的新主人的身份证
 *   swap(h[a], h[b]);           // 交换本体 h：真正交换这两个房间里的数据
 * 
 */

#include <iostream>
#include <algorithm>
#include <string>

using namespace std;

const int N = 100010;

int h[N];     // 堆数组 (从 1 开始存储)
int ph[N];    // ph[k] = idx: 第 k 个插入的数在堆中的下标
int hp[N];    // hp[idx] = k: 堆中下标为 idx 的数是第 k 个插入的
int sz;       // 堆当前的大小
int m;        // 记录当前是第几个插入的数字（历史身份证分配器，只会增加）

// ==========================================
// 核心逻辑：带映射的交换
// ==========================================
void heap_swap(int a, int b) {
    // 1. 交换 ph (通过 hp 找到对应的 k，然后交换 k 指向的 idx)
    //    解释：a 房间住着第 hp[a] 号人，b 房间住着第 hp[b] 号人。
    //         现在他们要互换房间，所以 ph[hp[a]] (a房间人的住址) 应该变成 b，
    //         ph[hp[b]] (b房间人的住址) 应该变成 a。
    swap(ph[hp[a]], ph[hp[b]]);
    
    // 2. 交换 hp (房间记录的身份证号互换)
    swap(hp[a], hp[b]);
    
    // 3. 交换真实值
    swap(h[a], h[b]);
}

// 向下调整 (沉底)
void down(int u) {
    int t = u;
    if (u * 2 <= sz && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= sz && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t) {
        heap_swap(u, t); // 【关键】必须使用 heap_swap
        down(t);
    }
}

// 向上调整 (上浮)
// 语法糖对比：为什么 down 用递归，up 用循环？
// 1. up (上浮) 是单行道：逻辑只有“我和父亲比”，路径唯一，循环写起来最顺手。
// 2. down (下沉) 是三岔路：逻辑是“我看左孩子、右孩子、我自己，三者取最小”，
//    交换后可能还得继续沉。虽然循环也能写，但递归能更自然地表达“在新位置重启检查逻辑”的语义。
//    (本质上两者都等价于 O(log N)，怎么写纯看个人习惯)
void up(int u) {
    while (u / 2 > 0 && h[u / 2] > h[u]) {
        heap_swap(u / 2, u); // 【关键】必须使用 heap_swap
        u /= 2;
    }
}

int main() {
    // 优化 I/O
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n;
    cin >> n;

    while (n -- ) {
        string op;
        int k, x;
        cin >> op;

        // 1. 插入一个数 (I x)
        // 普通堆逻辑：h[++sz] = x; up(sz);
        // 映射堆逻辑：多了维护 ph/hp 的步骤
        if (op == "I") {
            cin >> x;
            sz ++ ;
            m ++ ;          // m 是历史计数器，只增不减，用来发“身份证”
            
            ph[m] = sz;     // 履历表：第 m 个新人，现在住在 sz 号房间
            hp[sz] = m;     // 门牌号：sz 号房间，现在住着第 m 个新人
            h[sz] = x;      // 真实值
            
            up(sz);         // 新来的在队尾，向上挑战
        }
        // 2. 输出最小值 (PM)
        else if (op == "PM") {
            cout << h[1] << endl;
        }
        // 3. 删除最小值 (DM)
        // 普通堆逻辑：h[1] = h[sz]; sz--; down(1);
        // 映射堆逻辑：必须 swap，因为要把队尾元素的 ph/hp 属性带到堆顶去
        else if (op == "DM") {
            heap_swap(1, sz); // 把堆顶(最小值)和队尾互换
            sz -- ;           // 砍掉队尾(也就是原来的最小值)
            down(1);          // 新的堆顶(原来的队尾)肯定德不配位，向下沉
        }
        // 4. 删除第 k 个插入的数 (D k)
        // 普通堆做不到！因为它找不到第 k 个数在哪。
        else if (op == "D") {
            cin >> k;
            int idx = ph[k];  // 上帝视角：查雷达，直接找到第 k 个数现在的物理地址
            heap_swap(idx, sz); // 把它换到队尾
            sz -- ;             // 移除
            
            // 连招：up + down
            // 这个点换上来后，可能比父亲小(需要up)，也可能比儿子大(需要down)。
            // 两个只会触发一个，写全了最省事。
            up(idx);
            down(idx);
        }
        // 5. 修改第 k 个插入的数 (C k x)
        // 普通堆做不到！
        else if (op == "C") {
            cin >> k >> x;
            int idx = ph[k];  // 上帝视角精准定位
            h[idx] = x;       // 直接修改物理房间里的值
            
            // 还是那套连招，维持堆性质
            up(idx);
            down(idx);
        }
    }

    return 0;
}
