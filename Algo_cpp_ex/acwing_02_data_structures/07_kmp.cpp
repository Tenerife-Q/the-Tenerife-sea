/*
 * ============================================
 *   KMP字符串匹配 (Knuth-Morris-Pratt)
 *   题目来源: AcWing 831. KMP字符串
 * ============================================
 * 
 * 【问题】
 *   给定模式串 P 和长文本串 S，求 P 在 S 中出现的所有位置。
 * 
 * 【核心原理：Next 数组】
 *   ne[i] 表示：P[1...i] 这个子串中，【最长相等前后缀】的长度。
 * 
 *   图解 P = "ababa" 的 next 数组：
 *   i=1 "a"     -> 无前后缀 -> ne[1]=0
 *   i=2 "ab"    -> 前"a",后"b" -> ne[2]=0
 *   i=3 "aba"   -> 前"a",后"a" -> ne[3]=1
 *   i=4 "abab"  -> 前"ab",后"ab" -> ne[4]=2
 *   i=5 "ababa" -> 前"aba",后"aba" -> ne[5]=3
 * 
 * 【匹配原理：失配移动】
 *   当 S[i] 与 P[j+1] 不匹配时，j 不是回退到 0，而是回退到 ne[j]。
 *   这利用了 P 自己匹配自己的性质，将 P 往右滑动，让 P 的前缀对其 S 的后缀。
 * 
 *   S:  ... a b a b X ...  (i指向X, j=4指向b, j+1指向a)
 *   P:      a b a b a      (此时 S[i] != P[j+1])
 *            \ /
 *        ne[4]=2, j跳到2
 * 
 *   S:  ... a b a b X ...
 *   P:          a b a b a  (直接把 P 的前2位挪过来对齐)
 *               ^New j=2
 */

#include <iostream>

using namespace std;

const int N = 100010, M = 1000010;

/*
 * 变量定义图解：
 * n, p[N]: 模式串 "aba" -> p[1]='a', p[2]='b', p[3]='a'
 * m, s[M]: 文本串 "ababa"
 * ne[N]:   Next跳转表
 *
 * 索引说明：
 * 全部使用 1-based 索引 (下标从1开始)，这是KMP算法习惯，
 * 方便 ne[j] 直接映射长度 j 的前缀。
 */
int n, m;
char p[N], s[M];
int ne[N];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    // 输入字符串，下标从1开始存储
    cin >> n >> (p + 1);
    cin >> m >> (s + 1);

    // ==========================================
    // 1. 求 next 数组
    //    P = "ababa" (下标从1开始)
    // ==========================================
    // [Step 1] i=2, j=0
    //    P:  a  b  a  b  a
    //        ^j(0) ^i(2)
    //    比较: p[j+1]('a') vs p[i]('b') -> ❌ 不等
    //    回退: j=0 (无法回退) -> ne[2]=0
    // 
    // [Step 2] i=3, j=0
    //    P:  a  b  a  b  a
    //        ^j(0)    ^i(3)
    //    比较: p[j+1]('a') vs p[i]('a') -> ✅ 相等
    //    更新: j++ -> j=1; ne[3]=1
    //
    // [Step 3] i=4, j=1
    //    P:  a  b  a  b  a
    //           ^j(1)    ^i(4)
    //    比较: p[j+1]('b') vs p[i]('b') -> ✅ 相等
    //    更新: j++ -> j=2; ne[4]=2
    //
    // [Step 4] i=5, j=2
    //    P:  a  b  a  b  a
    //              ^j(2)    ^i(5)
    //    比较: p[j+1]('a') vs p[i]('a') -> ✅ 相等
    //    更新: j++ -> j=3; ne[5]=3
    for (int i = 2, j = 0; i <= n; i ++ ) {
        // [失配] j往回跳，直到跳到0或者 p[j+1] 能和 p[i] 匹配为止
        // 这里的 ne[j] 就像一个"备胎指针"
        while (j && p[i] != p[j + 1]) j = ne[j];
        
        // [匹配] 如果这一位能接上，最长公共前后缀长度 +1
        if (p[i] == p[j + 1]) j ++ ;
        
        ne[i] = j;
    }

    // ==========================================
    // 2. KMP 匹配
    //    S = "abaab", P = "aba" (ne={0,0,1})
    // ==========================================
    // [Step 1] i=1, j=0
    //    S:  a  b  a  a  b    P:  a  b  a
    //        ^i                   ^j+1
    //    比较: 'a'=='a' -> ✅ j=1
    //
    // [Step 2] i=2, j=1
    //    S:  a  b  a  a  b    P:  a  b  a
    //           ^i                   ^j+1
    //    比较: 'b'=='b' -> ✅ j=2
    //
    // [Step 3] i=3, j=2
    //    S:  a  b  a  a  b    P:  a  b  a
    //              ^i                   ^j+1
    //    比较: 'a'=='a' -> ✅ j=3 (==n) -> 🎯 匹配成功! 起始下标 i-n=0
    //    重置: j = ne[3] = 1 ("a"是重叠部分)
    //
    // [Step 4] i=4, j=1
    //    S:  a  b  a  a  b    P:     a  b  a
    //                 ^i             ^j+1 ('b')
    //    比较: s[i]('a') != p[2]('b') -> ❌ 失配!
    //    回退: j = ne[1] = 0
    //    重试: s[i]('a') == p[1]('a') -> ✅ j=1
    for (int i = 1, j = 0; i <= m; i ++ ) {
        // [失配] 如果 s[i] 和 p[j+1] 不一样，j 就查表回退
        // 只要还有旧的前缀 (j>0) 且配不上，就一直缩短前缀
        while (j && s[i] != p[j + 1]) j = ne[j];
        
        // [匹配] 如果一样，j 前进
        if (s[i] == p[j + 1]) j ++ ;
        
        // [成功] 如果 j 走完了 p 的长度
        if (j == n) {
            cout << i - n << " "; // 输出起始位置
            j = ne[j]; // 假装刚配完的这位也失效了，寻找重叠的匹配
        }
    }

    return 0;
}

/*

for(int i = 2, j = 0; i <= n; i++ ) {
    while(j && p[i] != p[j + 1]) j = ne[j];
    if(p[i] == p[j + 1]) j++;
    ne[i] = j;
}

for(int i = 1, j = 0; i <= m; i++ ) {
    while(j && s[i] != p[j + 1]) j = ne[j];
    if(s[i] == p[j + 1]) j++;
    if(j == n) {
        cout << i - n << " ";
        j = ne[j];
    }
}
    关于几个数组的说明：
    - p[N]: 存储模式串 P，下标从1开始。
    - s[M]: 存储文本串 S，下标从1开始。
    - ne[N]: 存储模式串 P 的 next 数组，ne[i] 表示 P[1...i] 的最长相等前后缀长度。
    1. 求 next 数组:
       - 外层循环 i 从 2 到 n，表示正在计算 ne[i]。
       - 内层循环 while 用于处理失配情况，j 是当前最长相等前后缀的长度。
       - 如果 p[i] 和 p[j+1] 不匹配，说明当前的最长相等前后缀不适用了，需要回退到更短的那个，即 j = ne[j]。
       - 如果匹配成功，j 增加 1，表示最长相等前后缀长度增加了。
       - 最后将计算得到的 j 赋值给 ne[i]。
    2. KMP 匹配:
       - 外层循环 i 从 1 到 m，表示正在扫描文本串 S。
       - 内层循环 while 用于处理失配情况，j 是当前已经匹配的模式串长度。
       - 如果 s[i] 和 p[j+1] 不匹配，需要回退 j 到 ne[j]。
       - 如果匹配成功，j 增加 1。
       - 当 j 等于 n 时，说明模式串 P 完全匹配了，此时输出匹配的起始位置 i-n，并将 j 回退到 ne[j] 以寻找下一个可能的匹配。
*/

