/*
 * ============================================
 *   KMP 字符串匹配 (Knuth-Morris-Pratt)
 *   核心思想：状态机模型 + 动态规划 (DP) + 俄罗斯套娃
 * ============================================
 * 
 * 【核心角色人设】
 *   - i (质检员)：主串(S)的当前扫描位置。永远只往右走，绝不回头！
 *   - j (功劳簿/最大前缀)：当前已经完美匹配的模式串(P)长度。
 *   - 目标 (p[j+1])：既然有了 j 个功劳，下一步要比对的自然是第 j+1 个字符。
 * 
 * 【ne 数组的数学本质：俄罗斯套娃与隐藏链表】
 *   - ne[i] 表示子串 P[1...i] 的【最长相等真前后缀】的长度。
 *   - 为什么 j = ne[j] 连续回退不会漏掉可能？
 *     假设已匹配 11 个字符 [ABABA] C [ABABA]。第 12 个失配。
 *     最长保底是 5 (ABABA)。如果 5 也失配，我们要找次长保底。
 *     因为前5和后5是克隆体，求整个 11 字符的次长前后缀，
 *     等价于求这 5 个字符 [ABABA] 自己的最长前后缀！也就是 ne[5] = 3。
 *     因此：j=11 -> ne[11](5) -> ne[5](3) -> ne[3](1) -> ne[1](0)。
 *     ne 数组在这里化身为一条单链表，j = ne[j] 就是在顺藤摸瓜遍历所有合法的"备胎"！
 * 
 * 【DP 的自洽闭环：模板匹配模板】
 *   - j = ne[j] : 消费过去保存的状态（找备胎）。
 *   - ne[i] = j : 生产当前的新状态（刻在石碑上留给未来）。
 */

#include <iostream>

using namespace std;

const int N = 100010, M = 1000010;

int n, m;
char p[N], s[M];
int ne[N]; // Next 数组 (Partial Match Table)

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    // 1-indexed 模板：下标从 1 开始，极致优雅（方便 j 代表长度）
    cin >> n >> (p + 1);
    cin >> m >> (s + 1);

    // ==========================================
    // 阶段一：求 ne 数组 (P 匹配 P，模板匹配模板)
    // ==========================================
    // i 从 2 开始（ne[1] 必然是 0）；j=0 表示初始功劳为 0
    for (int i = 2, j = 0; i <= n; i ++ ) {
        
        // 1. [失配回退 - 消费状态]
        //    遇到危机：拿新来的 p[i] 去和期望的 p[j+1] 拼刺刀。
        //    如果失配，顺着“备胎链表” j = ne[j] 不断回退，直到能匹配或退到 0。
        while (j && p[i] != p[j + 1]) j = ne[j];
        
        // 2. [匹配推进 - 状态更新]
        //    危机解除：如果看对眼了，功劳簿 j 增加 1 
        if (p[i] == p[j + 1]) j ++ ;
        
        // 3. [保存状态 - 生产未来]
        //    DP 归档：将子串 p[1...i] 的最终功劳刻在石碑上。
        ne[i] = j;
    }

    // ==========================================
    // 阶段二：KMP 真正匹配 (S 匹配 P)
    // ==========================================
    // 逻辑与上方“求 ne 数组”一模一样，只是把主串换成了 S
    for (int i = 1, j = 0; i <= m; i ++ ) {
        
        // 1. [失配回退] 拿着 s[i] 质检 p[j+1]
        //    如果在此时失配，说明虽然前面 j 位都对上了，但第 j+1 位不行。
        //    于是查表 ne[j]，把 P 往右挪，试图用较短的前缀来匹配 S 的后缀。
        while (j && s[i] != p[j + 1]) j = ne[j];
        
        // 2. [匹配推进] 牵手成功：匹配长度 +1
        if (s[i] == p[j + 1]) j ++ ;
        
        // 3. [修成正果] 匹配长度 j 达到了模式串总长度 n
        if (j == n) {
            // 输出匹配在主串中的起始下标 (题目要求输出起始坐标，i - n + 1 是1-based，转0-based则为 i - n)
            cout << i - n << " ";
            
            // 4. [借尸还魂] 匹配成功后，假装在最后这里失配了，榨干剩余价值。
            //    强行让 j 回退，去寻找下一次可能的重叠匹配！
            //    比如 S="aaaa", P="aa" -> 匹配完第一个"aa"后，j=2。
            //    回退 j=ne[2]=1，下一轮 i 继续对比时，就带着 j=1 的功劳去战斗。
            j = ne[j]; 
        }
    }

    return 0;
}

/*
能比上就不动 不相同就整体向后移
for(int i = 2, j = 0; i <= n; i++ ) {
    while(j && p[i] != p[j + 1]) j = ne[j];
    if(p[i] == p[j + 1]) j++;
    ne[i] = j;
}

for(int i = 1, j = 0; i <= m; i++ ) {
    while(j && s[i] != p[j + 1]) j = ne[j];
    if(s[i] == p[j + 1]) j++;
    if(j == n) {
        cout << i - n << " ";
        j = ne[j];
    }
}
    关于几个数组的说明：
    - p[N]: 存储模式串 P，下标从1开始。
    - s[M]: 存储文本串 S，下标从1开始。
    - ne[N]: 存储模式串 P 的 next 数组，ne[i] 表示 P[1...i] 的最长相等前后缀长度。
    1. 求 next 数组:
       - 外层循环 i 从 2 到 n，表示正在计算 ne[i]。
       - 内层循环 while 用于处理失配情况，j 是当前最长相等前后缀的长度。
       - 如果 p[i] 和 p[j+1] 不匹配，说明当前的最长相等前后缀不适用了，需要回退到更短的那个，即 j = ne[j]。
       - 如果匹配成功，j 增加 1，表示最长相等前后缀长度增加了。
       - 最后将计算得到的 j 赋值给 ne[i]。
    2. KMP 匹配:
       - 外层循环 i 从 1 到 m，表示正在扫描文本串 S。
       - 内层循环 while 用于处理失配情况，j 是当前已经匹配的模式串长度。
       - 如果 s[i] 和 p[j+1] 不匹配，需要回退 j 到 ne[j]。
       - 如果匹配成功，j 增加 1。
       - 当 j 等于 n 时，说明模式串 P 完全匹配了，此时输出匹配的起始位置 i-n，并将 j 回退到 ne[j] 以寻找下一个可能的匹配。
*/

/*
 * ==================================================================================
 * 🎬 终极考验：触发连续回退 (逐帧推演)
 *   为了让你能像看逐帧动画一样看懂这极其暴力的状态转移，
 *   我们模拟 P = "ABABAA" (前5个是 ABABA, 第6个是 A) 的计算过程。
 * ==================================================================================
 *
 * 【场景设定】
 *   - 上 (主串视角 i)：i 走到了 6，送来了字符 'A'。
 *   - 下 (模式视角 j)：手里攥着 j=3 的功劳（前缀 "ABA"）。
 *   - 备胎表 ne：目前已有 ne[1]=0, ne[2]=0, ne[3]=1, ne[4]=2, ne[5]=3。
 *   - 目标：计算 ne[6]。
 *
 * 🛑 第一回合：满怀期待的撞墙 (拼刺刀失败)
 * ------------------------------------------------------------------
 * 【心理活动】：
 *   上刚刚走完 5 个字符，下已经完美贴合了 3 个字符 ("ABA")。
 *   既然前 3 个都对上了，那下第 4 个字符 (P[4]='B')，能不能和上第 6 个字符 (P[6]='A') 对上？
 *
 * 【物理对齐图】：
 *          1 2 3 4 5 6
 *   上 P:  A B A B A A
 *              | | | X  <-- 上 P[6]('A') 试图匹配 下 P[4]('B')，失配！
 *   下 P:      A B A B A
 *              1 2 3 4 5
 *              \_j=3_/
 *              (手里有3个功劳)
 *
 * 【残酷现实】：'A' != 'B'！想凑成 "ABAB" 的梦碎了。代码触发 while 循环。
 *
 * ⏪ 第二回合：第一次时空跳跃 (消费链表找次长备胎)
 * ------------------------------------------------------------------
 * 【心理活动】：
 *   3 个字符 ("ABA") 的功劳保不住了，查备胎表 ne[3]=1。
 *   物理意思：在你刚才匹配好的 "ABA" 中，前 1 个 ("A") 和后 1 个 ("A") 是一样的。
 *   别从头开始！直接把下向右滑动，让你手里的 1 个功劳 ("A") 去对齐上刚刚结束的那个 "A"。
 *
 * 【代码执行】：j = ne[j] => j = ne[3] => j = 1。
 *
 * 【物理对齐图】：
 *          1 2 3 4 5 6
 *   上 P:  A B A B A A
 *                  | X  <-- 上 P[6]('A') 试图匹配 下 P[2]('B')，再次失配！
 *   下 P:          A B A B A
 *                  1 2 3
 *                 j=1
 *             (剩1个功劳)
 *
 * 【残酷现实】：'A' != 'B'，第二次失配！
 *
 * ⏪ 第三回合：第二次绝望回退 (退无可退的底线)
 * ------------------------------------------------------------------
 * 【心理活动】：
 *   1 个字符 ("A") 的功劳也保不住了。查备胎表 ne[1]=0。
 *   物理意思：没有任何捷径了，前缀和后缀无重合。下必须被无情滑到最右端，从零开始。
 *
 * 【代码执行】：j = ne[j] => j = ne[1] => j = 0。功劳彻底清零。
 *
 * 【物理对齐图】：
 *          1 2 3 4 5 6
 *   上 P:  A B A B A A
 *                    |  <-- 上 P[6]('A') 试图匹配 下 P[1]('A')，完美吻合！
 *   下 P:            A B A B A
 *                    1 2
 *                   j=0
 *                (0个功劳)
 *
 * 【绝处逢生】：while (j > 0) 停止。执行 if (p[i] == p[j+1])。
 *   拿出下第 1 个字符 ('A') 和上 ('A') 比对。
 *   奇迹发生：'A' == 'A'！匹配成功！
 *
 * 🏆 第四回合：状态推进与 DP 刻碑
 * ------------------------------------------------------------------
 * 【动作 1：功劳增加】
 *   j++ => j=1。
 *
 * 【动作 2：DP 归档 (刻石碑)】
 *   ne[6] = j => ne[6] = 1。
 *
 * 🧠 终极大总结：数学神谕的验证
 * ------------------------------------------------------------------
 * 字符串：A B A B A A
 * 我们要找它的最长相等真前后缀：
 *   - 长度 5 (ABABA vs BABAA) ? 错
 *   - 长度 4 (ABAB vs ABAA)   ? 错
 *   - 长度 3 (ABA vs BAA)     ? 错
 *   - 长度 2 (AB vs AA)       ? 错
 *   - 长度 1 (A vs A)         ? 对！ (ne[6]=1)
 *
 * KMP 仅仅通过 2 次查表 (j=3 -> j=1 -> j=0)，就完美跳过了所有不可能选项，
 * 极其精准地锁定了长度 1。这就是数学理论兜底的暴力美学。
 */

