/*
 * ============================================
 *   字符串哈希 (String Hash): 字符串处理的"魔法指纹"
 *   题目来源: AcWing 841. 字符串哈希
 * ============================================
 * 
 * 【物理视角的本质】
 *   如果我们想判断两个长字符串是否相等，挨个比对需要 O(N) 的时间。
 *   哈希的做法是：把每一个字符串看作在一个超级巨大的 P 进制坐标系下的一个整数。
 *   如果两个字符串计算出的整数值相等，我们就认为这两个字符串"在极大概率上"是相等的。
 * 
 *   核心思想：Rolling Hash (滚动哈希) / BKDRHash
 *   把字符串 "ABCD" 看作 P 进制数: A*P^3 + B*P^2 + C*P^1 + D*P^0
 * 
 * 【核心公式】
 *   1. 前缀哈希: h[i] = h[i-1] * P + str[i]
 *      (物理动作：整个串左移一位，腾出个空位，把新字符塞进去)
 * 
 *   2. 区间哈希: h[l, r] = h[r] - h[l-1] * P^(r-l+1)
 *      (物理动作：类似于前缀和，但因为位权不同，需要先把 h[l-1] 对齐到 h[r] 的同一个数量级，再相减)
 * 
 * 【经验参数】
 *   - P (进制数): 经验值 131 或 13331 (减少冲突)
 *   - Mod (模数): 2^64 (直接利用 unsigned long long 的自然溢出性质，省去 % 运算)
 * 
 * 【复杂度】
 *   - 预处理: O(N)
 *   - 单次查询: O(1) ! (这是相比 KMP 最变态的优势)
 */

#include <iostream>

using namespace std;

// ULL = unsigned long long
// 范围 [0, 2^64-1]。
// 当计算结果超过 2^64 时，它会自动溢出回绕。这等价于对 2^64 取模！
// 这是一个极其巧妙的利用计算机底层特性的技巧。
typedef unsigned long long ULL;

const int N = 100010;
const int P = 131; // P 进制的基数

int n, m;
char str[N];

// h[N]: 哈希数组。h[i] 存储的是前缀字符串 str[1...i] 的哈希值。
// p[N]: 次方数组。p[i] 存储的是 P^i。
ULL h[N], p[N];

// 【核心操作：计算子串哈希值】
// 类似于前缀和公式：sum[l, r] = s[r] - s[l-1]
// 但这里涉及位权。比如 "ABCDE"，我们要算 "CDE"。
// h[r] (ABCDE) 包含了 A*P^4 + B*P^3 + C*P^2 + D*P^1 + E*P^0
// h[l-1] (AB)  包含了 A*P^1 + B*P^0
// 必须把 AB 左移 3 位 (乘以 P^3)，变成 A*P^4 + B*P^3，才能和 ABCDE 对齐相减。
// 这里的 3 正好是 len = r - l + 1。
ULL get(int l, int r) {
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    // 读入字符串 (下标从 1 开始，方便前缀处理)
    cin >> n >> m >> (str + 1);

    // 【预处理哈希前缀】
    p[0] = 1; // P^0 = 1
    for (int i = 1; i <= n; i ++ ) {
        // 1. 预处理次方 P^i
        p[i] = p[i - 1] * P;
        
        // 2. 预处理前缀哈希
        // 物理意义：把前面的串左移一位 (*P)，然后加上当前的字符值。
        // 注意：str[i] 可以直接当成数字用 (ASCII码)。
        h[i] = h[i - 1] * P + str[i];
    }

    while (m -- ) {
        int l1, r1, l2, r2;
        cin >> l1 >> r1 >> l2 >> r2;

        // 如果两个子串的哈希值（指纹）相同，我们就认为这就是同一个字符串。
        // (极小概率发生哈希冲突，但在算法竞赛中通常忽略不计)
        if (get(l1, r1) == get(l2, r2)) cout << "Yes" << endl;
        else cout << "No" << endl;
    }

    return 0;
}

/*
 * ==================================================================================
 * 🔍 深度辨析：为什么要乘以 P^(r-l+1)？(对齐原理)
 * ==================================================================================
 * 
 * 假设 P=10 (十进制), 字符串 "12345"。
 * 我们想求 "345" 的值。
 * 
 * Known:
 * h[5] ("12345") = 12345
 * h[2] ("12")    = 12
 * 
 * 如果直接 h[5] - h[2] = 12345 - 12 = 12333 (❌ 错误！)
 * 这里的 "12" 在 h[5] 里其实代表的是 12000 (万位和千位)。
 * 
 * 所以必须先把 h[2] 左移 3 位 (乘以 10^3):
 * 12 * 1000 = 12000
 * 
 * 然后再减:
 * h[5] - (h[2] * 10^3) 
 * = 12345 - 12000 
 * = 345 (✅ 正确！)
 * 
 * 在 P 进制下同理，左移几位取决于子串长度 len = r - l + 1。
 * 公式：h[l, r] = h[r] - h[l-1] * P^(r-l+1)
 */
