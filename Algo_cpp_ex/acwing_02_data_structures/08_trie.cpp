/*
 * ============================================
 *   Trie字典树 (Prefix Tree)
 *   题目来源: AcWing 835. Trie字符串统计
 * ============================================
 * 
 * 【物理定义：内存快照与指针追踪】
 *   1. p: 当前游走的节点编号 (游标)。
 *   2. idx: 全局递增的"新节点分配器" (内存池指针)。
 *   3. son[p][u]: 从节点 p 出发，通过字符 u (0-25)，指向的子节点编号。
 *      - 第一维 p: 当前节点的"物理地址" (房间号)。
 *      - 第二维 u: 当前节点的"边的路径" (门牌号 'a'->0, 'b'->1)。
 *      - 值 son[p][u]: 存储的是子节点的房间号。若为 0，代表此路不通(nullptr)。
 * 
 * 【核心操作】
 *   - 插入: 顺着路径走，没有路就铺路 (++idx)，走到终点打标记 (cnt++)。
 *   - 查询: 顺着路径走，路断了就是没有，走到终点看标记 (cnt)。
 * 
 * 【性能优势】
 *   相比链表动态 new 节点，数组模拟 (son[N][26]) 分配的是连续内存。
 *   CPU 访问时 Cache Hit (缓存命中率) 极高，常数极小，速度飞快。
 */

#include <iostream>

using namespace std;

const int N = 100010;

// son[p][u] 存储树中每个节点的子节点
// - p: 父节点下标
// - u: 边的字符映射 (0-'a', 1-'b'...)
// - 值: 子节点下标
int son[N][26];

// cnt[p] 存储以节点 p 结尾的单词数量
int cnt[N];

// idx 当前用到了哪个下标 (High Water Mark of Memory Pool)
// 0号点既是根节点，也是空节点
int idx;

char str[N];

void insert(char *str) {
    int p = 0;  // 从根节点 0 开始
    for (int i = 0; str[i]; i ++ ) {
        int u = str[i] - 'a'; // 将 'a'-'z' 映射为 0-25
        
        // 如果当前节点 p 没有通往 u 的路，就开辟一条新路
        // ++idx 分配一个新的节点编号
        if (!son[p][u]) son[p][u] = ++ idx;
        
        // 走到下一个节点
        p = son[p][u];
    }
    // 循环结束，p 停留在单词的最后一个字符对应的节点上
    // 打上标记，表示以此节点结尾的单词多了一个
    cnt[p] ++ ;
}

int query(char *str) {
    int p = 0;
    for (int i = 0; str[i]; i ++ ) {
        int u = str[i] - 'a';
        
        // 如果路断了，说明树里没有这个前缀/单词
        if (!son[p][u]) return 0;
        
        p = son[p][u];
    }
    // 走到终点，看看这个位置标记了多少个单词
    // 注意：如果只插入了 "abc"，查 "ab" 时 p 会停在 'b' 的节点
    // 此时 cnt[p] 为 0，正确返回 0。
    return cnt[p];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n;
    cin >> n;
    while (n -- ) {
        char op[2];
        cin >> op >> str;
        if (*op == 'I') insert(str);
        else cout << query(str) << endl;
    }

    return 0;
}



/*
int idx;

void insert(char *str) {
    int p = 0;
    for(int i = 0; str[i]; i++ ) {
        int u = str[i] - 'a';
        if(!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p]++;
}

int query(char *str) {
    int p = 0;
    for(int i = 0; str[i]; i++ ) {
        int u = str[i] - 'a';
        if(!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
*/




/*
 * ==================================================================================
 * 🎬 Trie 树内存演变逐帧动画 (Memory Trace)
 * ==================================================================================
 * 
 * 初始状态：idx = 0, son 全 0, cnt 全 0。
 * 
 * 1. 执行 insert("abc")
 * -----------------------------------------------------------
 * - 字符 'a' (u=0): 
 *   p=0, son[0][0]不存在 -> 分配 idx=1, son[0][0]=1 -> p移动到 1
 * - 字符 'b' (u=1): 
 *   p=1, son[1][1]不存在 -> 分配 idx=2, son[1][1]=2 -> p移动到 2
 * - 字符 'c' (u=2): 
 *   p=2, son[2][2]不存在 -> 分配 idx=3, son[2][2]=3 -> p移动到 3
 * - 结束: 
 *   在节点 3 打标记 -> cnt[3] = 1
 * 
 *   [内存快照]:
 *   (0) --a--> (1) --b--> (2) --c--> (3)[cnt=1]
 * 
 * 2. 执行 insert("abd")
 * -----------------------------------------------------------
 * - 字符 'a' (u=0): 
 *   p=0, son[0][0]=1 (已存在) -> 复用路径 -> p移动到 1
 * - 字符 'b' (u=1): 
 *   p=1, son[1][1]=2 (已存在) -> 复用路径 -> p移动到 2
 * - 字符 'd' (u=3): 
 *   p=2, son[2][3]不存在 -> 分配 idx=4, son[2][3]=4 -> p移动到 4
 * - 结束: 
 *   在节点 4 打标记 -> cnt[4] = 1
 * 
 *   [内存快照]:                /--c--> (3)[cnt=1] ("abc")
 *   (0) --a--> (1) --b--> (2) 
 *                              \--d--> (4)[cnt=1] ("abd")
 * 
 * 3. 执行 query("ab")
 * -----------------------------------------------------------
 * - 字符 'a' (u=0): p=0 -> son[0][0]=1 -> p移动到 1
 * - 字符 'b' (u=1): p=1 -> son[1][1]=2 -> p移动到 2
 * - 结束: 返回 cnt[2]。
 *   查看内存，节点 2 只是路径节点，从未作为终点打过标记，cnt[2]=0。
 *   结果正确。
 */

/*
 * ==================================================================================
 * 🔍 深度辨析：工程与算法竞赛的核心分歧
 * ==================================================================================
 * 
 * ❓ 为什么要有两套写法？
 *    - LeetCode/教科书 (OOP): 强调封装、可读性、面向对象。使用 Node* next[26]。
 *    - AcWing/竞赛 (Array): 强调极致性能、Cache 命中率、编写速度。使用 son[N][26]。
 * 
 * 1. 核心字段的一一映射 (Mapping)
 * ----------------------------------------------------------------------------------
 * 
 * [A] 树的边 (Edges)
 *   - OOP:  curr->next[u]      // 指针：当前节点 curr 通过字符 u 指向的下一个节点的【内存地址】
 *   - Array: son[p][u]         // 数组：当前节点 p    通过字符 u 指向的下一个节点的【数组下标】
 *   > 物理意义：代表 26 扇门。son[p][u] 存的值就是子节点的“房间号”。
 * 
 * [B] 内存分配 (Allocation)
 *   - OOP:  new TrieNode()     // 系统调用：在堆内存碎片中寻找空间 (慢)
 *   - Array: ++idx             // 计数器：  在预分配的连续大数组中拿下一个位置 (快)
 *   > 物理意义：idx 是无情的“房号分发器”。
 * 
 * [C] 节点属性 (Payload)
 *   - OOP:  curr->cnt          // 结构体成员变量
 *   - Array: cnt[p]            // 并行的属性数组
 *   > 物理意义：cnt[3] 代表 3 号房间存放的数据。如果需要存更多属性(如长度)，
 *     只需再开一个数组 int len[N]，用 len[p] 访问即可。
 * 
 * 2. 为什么竞赛坚决使用数组模拟？
 * ----------------------------------------------------------------------------------
 *   (1) 极端的执行速度 (Cache Friendly):
 *       数组 son[][] 在物理内存中是连续的。CPU 预读机制会将整块数据加载到 L1/L2 缓存。
 *       而 new 出来的节点散落在堆内存各处，指针跳转时会导致大量的 Cache Miss。
 * 
 *   (2) 绝对的安全 (No Memory Leak):
 *       竞赛程序运行几秒即结束，操作系统统一回收。无需编写 delete 逻辑，避免段错误。
 * 
 *   (3) 代码简短 (Code Golf):
 *       没有结构体声明，没有构造函数。insert 函数仅需 5 行。
 */
