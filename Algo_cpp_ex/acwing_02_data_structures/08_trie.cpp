/*
 * ============================================
 *   Trie字典树 (Prefix Tree)
 *   题目来源: AcWing 835. Trie字符串统计
 * ============================================
 * 
 * 【物理定义：内存快照与指针追踪】
 *   1. p: 当前游走的节点编号 (游标)。
 *   2. idx: 全局递增的"新节点分配器" (内存池指针)。
 *   3. son[p][u]: 从节点 p 出发，通过字符 u (0-25)，指向的子节点编号。
 *      - 这是一个二维数组，son[N][26]。
 *      - 第一维 N 是节点池，第二维 26 是岔路口。
 * 
 * 【核心操作】
 *   - 插入: 顺着路径走，没有路就铺路 (++idx)，走到终点打标记 (cnt++)。
 *   - 查询: 顺着路径走，路断了就是没有，走到终点看标记 (cnt)。
 * 
 * 【性能优势】
 *   相比链表动态 new 节点，数组模拟 (son[N][26]) 分配的是连续内存。
 *   CPU 访问时 Cache Hit (缓存命中率) 极高，常数极小，速度飞快。
 */

#include <iostream>

using namespace std;

const int N = 100010;

// son[p][u] 存储树中每个节点的子节点
// - p: 父节点下标
// - u: 边的字符映射 (0-'a', 1-'b'...)
// - 值: 子节点下标
int son[N][26];

// cnt[p] 存储以节点 p 结尾的单词数量
int cnt[N];

// idx 当前用到了哪个下标 (High Water Mark of Memory Pool)
// 0号点既是根节点，也是空节点
int idx;

char str[N];

void insert(char *str) {
    int p = 0;  // 从根节点 0 开始
    for (int i = 0; str[i]; i ++ ) {
        int u = str[i] - 'a'; // 将 'a'-'z' 映射为 0-25
        
        // 如果当前节点 p 没有通往 u 的路，就开辟一条新路
        // ++idx 分配一个新的节点编号
        if (!son[p][u]) son[p][u] = ++ idx;
        
        // 走到下一个节点
        p = son[p][u];
    }
    // 循环结束，p 停留在单词的最后一个字符对应的节点上
    // 打上标记，表示以此节点结尾的单词多了一个
    cnt[p] ++ ;
}

int query(char *str) {
    int p = 0;
    for (int i = 0; str[i]; i ++ ) {
        int u = str[i] - 'a';
        
        // 如果路断了，说明树里没有这个前缀/单词
        if (!son[p][u]) return 0;
        
        p = son[p][u];
    }
    // 走到终点，看看这个位置标记了多少个单词
    // 注意：如果只插入了 "abc"，查 "ab" 时 p 会停在 'b' 的节点
    // 此时 cnt[p] 为 0，正确返回 0。
    return cnt[p];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n;
    cin >> n;
    while (n -- ) {
        char op[2];
        cin >> op >> str;
        if (*op == 'I') insert(str);
        else cout << query(str) << endl;
    }

    return 0;
}

/*
 * ==================================================================================
 * 🎬 Trie 树内存演变逐帧动画 (Memory Trace)
 * ==================================================================================
 * 
 * 初始状态：idx = 0, son 全 0, cnt 全 0。
 * 
 * 1. 执行 insert("abc")
 * -----------------------------------------------------------
 * - 字符 'a' (u=0): 
 *   p=0, son[0][0]不存在 -> 分配 idx=1, son[0][0]=1 -> p移动到 1
 * - 字符 'b' (u=1): 
 *   p=1, son[1][1]不存在 -> 分配 idx=2, son[1][1]=2 -> p移动到 2
 * - 字符 'c' (u=2): 
 *   p=2, son[2][2]不存在 -> 分配 idx=3, son[2][2]=3 -> p移动到 3
 * - 结束: 
 *   在节点 3 打标记 -> cnt[3] = 1
 * 
 *   [内存快照]:
 *   (0) --a--> (1) --b--> (2) --c--> (3)[cnt=1]
 * 
 * 2. 执行 insert("abd")
 * -----------------------------------------------------------
 * - 字符 'a' (u=0): 
 *   p=0, son[0][0]=1 (已存在) -> 复用路径 -> p移动到 1
 * - 字符 'b' (u=1): 
 *   p=1, son[1][1]=2 (已存在) -> 复用路径 -> p移动到 2
 * - 字符 'd' (u=3): 
 *   p=2, son[2][3]不存在 -> 分配 idx=4, son[2][3]=4 -> p移动到 4
 * - 结束: 
 *   在节点 4 打标记 -> cnt[4] = 1
 * 
 *   [内存快照]:                /--c--> (3)[cnt=1] ("abc")
 *   (0) --a--> (1) --b--> (2) 
 *                              \--d--> (4)[cnt=1] ("abd")
 * 
 * 3. 执行 query("ab")
 * -----------------------------------------------------------
 * - 字符 'a' (u=0): p=0 -> son[0][0]=1 -> p移动到 1
 * - 字符 'b' (u=1): p=1 -> son[1][1]=2 -> p移动到 2
 * - 结束: 返回 cnt[2]。
 *   查看内存，节点 2 只是路径节点，从未作为终点打过标记，cnt[2]=0。
 *   结果正确。
 */
