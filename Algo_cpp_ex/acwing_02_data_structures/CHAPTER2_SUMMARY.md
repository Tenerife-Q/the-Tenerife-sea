# AcWing 算法基础课 - 第二章：数据结构深度总结

> **核心哲学：用静态数组模拟一切**  
> 在算法竞赛中，为了追求极致的性能（缓存命中率+无动态内存分配开销），我们将所有复杂的指针结构（链表、树、堆、哈希表）全部拍扁进一维数组中。

## 📚 目录体系

### 第一部分：线性结构的物理模拟
| 文件 | 物理模型 | 核心数组 | 关键技巧 |
|:---:|:---|:---|:---|
| **01_单链表** | 每个人手里攥着下一个人的门牌号 | `e[], ne[], head, idx` | 头插法最快 $O(1)$ |
| **02_双链表** | 左手拉前任，右手拉后任 | `l[], r[], e[], idx` | 0和1做哨兵，idx从2开始 |
| **03_栈** | 只有一个口的死胡同 | `stk[], tt` | `tt=0` 表示空 |
| **04_队列** | 奶茶店排队，队头取餐队尾进 | `q[], hh, tt` | `hh <= tt` 表示非空 |

### 第二部分：字符串与高级线性
| 文件 | 物理模型 | 核心数组 | 关键技巧 |
|:---:|:---|:---|:---|
| **05_单调栈** | 只有比我矮的才能站在我上面 | `stk[], tt` | 找**左边**第一个比我小的数 |
| **06_单调队列** | "如果一个人比你小还比你强" | `q[]` (存下标) | 滑动窗口求最值 (双端队列) |
| **07_KMP** | 状态机不断回退找备胎 | `ne[]` (Next数组) | **移花接木**：利用已匹配信息跳过无效尝试 |
| **08_Trie树** | 26个门的无限迷宫酒店 | `son[N][26], cnt[], idx` | **房间号**与**字符**的映射关系 |

### 第三部分：集合与图论基础
| 文件 | 物理模型 | 核心数组 | 关键技巧 |
|:---:|:---|:---|:---|
| **09_并查集** | 只有老大的办公室才知道部门归属 | `p[]` (存父节点) | **路径压缩** (一步登天) + 递归回溯 |
| **10_堆(普通)** | 完全二叉树的金字塔 | `h[]` | 下标从1开始，`x/2`找爹，`2x`找儿 |
| **13_堆(带映射)** | 给数据装GPS定位系统 | `ph[], hp[]` | **反向索引**：支持 $O(\log N)$ 修改任意第k个插入的数 |

### 第四部分：哈希与散列
| 文件 | 物理模型 | 核心数组 | 关键技巧 |
|:---:|:---|:---|:---|
| **11_哈希表** | 蹲坑法(开放寻址) vs 拉链法 | `h[], e[], ne[]` | 模数取质数 (如 100003)，减少冲突 |
| **12_字符串Hash** | P进制数在哈希传送带上流动 | `h[], p[]` | **前缀和思想**：$H[R] - H[L-1] \times P^{R-L+1}$ |

---

## 💡 深度复盘：核心难点解析

### 1. KMP 的 `ne` 数组 (Next Array)
- **本质**：当匹配失败时，我是不是真的要重头再来？不需要！`ne[j]` 告诉我们可以回退到的最长合法前缀。
- **名言**：“借尸还魂”——利用已经匹配的信息，继续下一轮战斗。

### 2. Trie 的 `idx` 分配
- **本质**：`idx` 既是时间戳（第几个被创建的节点），也是物理地址（数组下标）。
- **误区**：新手容易混淆 `son[u][k]` 中的 `u`（父节点地址）和 `k`（边的字符映射）。`son` 的值才是子节点的物理地址。

### 3. 并查集 (Union-Find)
- **本质**：维护集合归属关系。
- **大杀器**：`find` 函数中的路径压缩 `p[x] = find(p[x])`。这行代码让树的高度瞬间变成近乎 1，查询复杂度降为 $O(1)$ (Ackermann反函数)。

### 4. 堆的 `down` 与 `up`
- **本质**：维护集合的最值（通常是最小值）。
- **带映射堆 (Mapped Heap)**：这是数组模拟的巅峰。为了支持“修改第 k 个插入的数”，我们引入了 `ph` (Pointer->Heap) 和 `hp` (Heap->Pointer) 两个互逆数组，让 `swap` 操作变成了三位一体的原子操作。

### 5. 字符串 Hash (Rolling Hash)
- **本质**：把字符串看作一个 P 进制的整数。通过 `unsigned long long` 的自然溢出代替取模。
- **公式**：通过前缀哈希数组 `h[]`，我们可以 $O(1)$ 算出任意子串的 Hash 值，从而判断两个子串是否相等。这是 KMP 的某种替代方案，但更通用（如处理回文串）。

---

## 🛠️ 下一步建议
整个数据结构章节构建了后续图论（Graph）和动态规划（DP）的基石：
1. **必须熟练**：单链表（邻接表基础）、堆（Dijkstra基础）、并查集（Kruskal基础）。
2. **可以最后攻克**：KMP 和 带映射堆（逻辑较绕）。